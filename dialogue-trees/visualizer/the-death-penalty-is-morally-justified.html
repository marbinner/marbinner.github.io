<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The death penalty is morally justified - Graph View</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Inline critical styles (graph.css will be external for customization) */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e8eef5 100%);
            overflow: hidden;
        }

        #header {
            background: white;
            border-bottom: 1px solid #a2a9b1;
            padding: 15px 20px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            height: 70px;
        }

        #header h1 {
            font-size: 1.3em;
            font-weight: 400;
            color: #202122;
            margin-bottom: 5px;
        }

        #header .meta {
            font-size: 0.85em;
            color: #72777d;
        }

        #controls {
            position: fixed;
            top: 80px;
            left: 10px;
            background: white;
            border: 1px solid #a2a9b1;
            border-radius: 4px;
            padding: 15px;
            z-index: 100;
            max-width: 250px;
        }

        #controls h3 {
            font-size: 0.9em;
            font-weight: 600;
            margin-bottom: 10px;
            color: #202122;
        }

        #controls input[type="text"] {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #a2a9b1;
            border-radius: 3px;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        #controls button {
            width: 100%;
            padding: 6px 10px;
            margin-bottom: 5px;
            border: 1px solid #a2a9b1;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.85em;
        }

        #controls button:hover {
            background: #eaecf0;
        }

        #legend {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eaecf0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 5px;
        }

        .stat-item {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #eaecf0;
            border-left-width: 3px;
            border-left-color: #0645ad;
        }

        .stat-label {
            display: block;
            font-size: 0.7em;
            color: #72777d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 3px;
        }

        .stat-number {
            display: block;
            font-size: 1.3em;
            font-weight: 600;
            color: #202122;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.85em;
        }

        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            margin-right: 10px;
            flex-shrink: 0;
        }

        #sidebar {
            position: fixed;
            top: 70px;
            right: -550px;
            width: 520px;
            height: calc(100vh - 70px);
            background: white;
            border-left: 2px solid #a2a9b1;
            transition: right 0.3s ease;
            z-index: 100;
            overflow-y: auto;
            padding: 0;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.1);
        }

        #sidebar.open {
            right: 0;
        }

        #sidebar .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #f8f9fa;
            border: 1px solid #a2a9b1;
            border-radius: 4px;
            width: 32px;
            height: 32px;
            font-size: 1.3em;
            cursor: pointer;
            color: #72777d;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 10;
        }

        #sidebar .close-btn:hover {
            background: #eaecf0;
            color: #202122;
        }

        #sidebar-header {
            background: #f8f9fa;
            border-bottom: 1px solid #eaecf0;
            padding: 20px 25px;
            padding-right: 55px;
        }

        #sidebar-header h2 {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 8px;
            color: #202122;
        }

        .breadcrumb {
            font-size: 0.8em;
            color: #72777d;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 5px;
        }

        .breadcrumb-item {
            cursor: pointer;
            transition: color 0.2s;
        }

        .breadcrumb-item:hover {
            color: #0645ad;
            text-decoration: underline;
        }

        .breadcrumb-separator {
            color: #a2a9b1;
            margin: 0 3px;
        }

        #sidebar-body {
            padding: 20px 25px;
        }

        .section {
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 0.9em;
            font-weight: 600;
            color: #72777d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .node-text {
            font-size: 0.95em;
            line-height: 1.7;
            color: #202122;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #0645ad;
        }

        .node-badge-large {
            display: inline-block;
            font-size: 0.75em;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-right: 8px;
        }

        .node-badge-large.pro {
            background: #d5f0e8;
            color: #2d9e7e;
            border: 1px solid #2d9e7e;
        }

        .node-badge-large.con {
            background: #f7e0e0;
            color: #c74848;
            border: 1px solid #c74848;
        }

        .node-badge-large.objection {
            background: #ffecd9;
            color: #d97a30;
            border: 1px solid #d97a30;
        }

        .node-badge-large.response {
            background: #e3eef8;
            color: #4a7fb8;
            border: 1px solid #4a7fb8;
        }

        .meta-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 10px;
        }

        .meta-item {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #eaecf0;
        }

        .meta-label {
            font-size: 0.75em;
            color: #72777d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .meta-value {
            font-size: 1em;
            font-weight: 600;
            color: #202122;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .action-btn {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #a2a9b1;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .action-btn:hover {
            background: #f8f9fa;
            border-color: #0645ad;
            color: #0645ad;
        }

        .action-btn.primary {
            background: #0645ad;
            color: white;
            border-color: #0645ad;
        }

        .action-btn.primary:hover {
            background: #0051a0;
        }

        .child-node {
            background: white;
            border: 1px solid #eaecf0;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 4px solid transparent;
        }

        .child-node:hover {
            border-color: #0645ad;
            border-left-color: #0645ad;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .child-node.pro {
            border-left-color: #2d9e7e;
        }

        .child-node.con {
            border-left-color: #c74848;
        }

        .child-node.objection {
            border-left-color: #d97a30;
        }

        .child-node.response {
            border-left-color: #4a7fb8;
        }

        .child-node-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .child-node-badge {
            font-size: 0.7em;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .child-node-text {
            font-size: 0.9em;
            line-height: 1.5;
            color: #202122;
        }

        .references-list {
            list-style: none;
            padding: 0;
        }

        .references-list li {
            margin-bottom: 8px;
            padding-left: 20px;
            position: relative;
        }

        .references-list li:before {
            content: "üîó";
            position: absolute;
            left: 0;
        }

        .references-list a {
            color: #0645ad;
            text-decoration: none;
            font-size: 0.85em;
            word-break: break-all;
        }

        .references-list a:hover {
            text-decoration: underline;
        }

        .empty-state {
            text-align: center;
            padding: 30px 20px;
            color: #72777d;
            font-size: 0.9em;
        }

        .stats-row {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .stat-box {
            text-align: center;
        }

        .stat-box-value {
            font-size: 1.4em;
            font-weight: 600;
            color: #0645ad;
        }

        .stat-box-label {
            font-size: 0.75em;
            color: #72777d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        #graph-container {
            position: fixed;
            top: 70px;
            left: 0;
            right: 0;
            bottom: 0;
        }

        svg {
            width: 100%;
            height: 100%;
        }

        .node {
            cursor: pointer;
        }

        .node circle {
            stroke: none;
            fill: transparent;
            opacity: 0;
            /* Keep circles for physics/collision detection but hide them */
        }

        /* Highlighted and selected states now apply to text boxes */
        .node.highlighted .node-text-content {
            outline: 3px solid #ffd700;
            outline-offset: 2px;
        }

        .node.selected .node-text-content {
            outline: 3px solid #0645ad;
            outline-offset: 2px;
        }

        /* foreignObject for text wrapping */
        .node foreignObject {
            overflow: visible;
            pointer-events: auto;  /* Make text boxes clickable */
        }

        .node-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            pointer-events: auto;  /* Make labels clickable */
        }

        .node-badge {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-bottom: 3px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.2);
        }

        .node-badge.pro {
            color: #2d9e7e;
            border-color: #2d9e7e;
        }

        .node-badge.con {
            color: #c74848;
            border-color: #c74848;
        }

        .node-badge.objection {
            color: #d97a30;
            border-color: #d97a30;
        }

        .node-badge.response {
            color: #4a7fb8;
            border-color: #4a7fb8;
        }

        .node-text-content {
            color: #202122;
            line-height: 1.4;
            word-wrap: break-word;
            background: rgba(255, 255, 255, 0.95);
            padding: 6px 10px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-left-width: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        /* Color-coded left borders by node type */
        .node.pro .node-text-content {
            border-left-color: #2d9e7e;
            background: rgba(213, 240, 232, 0.85);
        }

        .node.con .node-text-content {
            border-left-color: #c74848;
            background: rgba(247, 224, 224, 0.85);
        }

        .node.objection .node-text-content {
            border-left-color: #d97a30;
            background: rgba(255, 236, 217, 0.85);
        }

        .node.response .node-text-content {
            border-left-color: #4a7fb8;
            background: rgba(227, 238, 248, 0.85);
        }

        /* Depth-based opacity for hierarchy */
        .node.depth-0 .node-text-content {
            opacity: 1;
        }

        .node.depth-1 .node-text-content {
            opacity: 0.95;
        }

        .node.depth-2 .node-text-content {
            opacity: 0.9;
        }

        .node.depth-3 .node-text-content {
            opacity: 0.85;
        }

        .node.depth-4 .node-text-content {
            opacity: 0.8;
        }

        .node.depth-5 .node-text-content {
            opacity: 0.75;
        }

        /* Meta node text gets special styling */
        .node.meta-pro .node-text-content,
        .node.meta-con .node-text-content {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px 16px;
            font-weight: 700;
            font-size: 18px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border-left-width: 5px;
        }

        .node.meta-pro .node-text-content {
            background: rgba(213, 240, 232, 0.95);
            border-left-color: #2d9e7e;
        }

        .node.meta-con .node-text-content {
            background: rgba(247, 224, 224, 0.95);
            border-left-color: #c74848;
        }

        /* Subtle hover effects */
        .node:hover .node-text-content {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .link:hover {
            stroke-opacity: 0.8 !important;
            stroke-width: 3px;
        }

        .node title {
            font-size: 14px;
        }

        .link {
            stroke: #8b95a5;
            stroke-opacity: 0.3;
            fill: none;
            transition: all 0.2s ease;
        }

        /* Unified link styling - all types use same neutral color for cleaner look */
        .link.pro,
        .link.con,
        .link.objection,
        .link.response {
            stroke: #8b95a5;
            stroke-opacity: 0.3;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>The death penalty is morally justified</h1>
        <div class="meta">
            4 arguments for ‚Ä¢ 4 arguments against ‚Ä¢
            33 total nodes ‚Ä¢ Max depth: 3 ‚Ä¢
            Version 4
        </div>
    </div>

    <div id="controls">
        <a href="../debates/the-death-penalty-is-morally-justified.html" style="display: block; width: 100%; padding: 8px 10px; margin-bottom: 10px; text-align: center; background: #0645ad; color: white; border-radius: 3px; text-decoration: none; font-size: 0.85em; font-weight: 500;">üìñ View Debate Page</a>

        <h3>üîç Search & Navigate</h3>
        <input type="text" id="search" placeholder="Search arguments...">
        <button onclick="resetAndFit()">üéØ Reset & Fit View</button>

        <div id="legend">
            <h3>üìä Tree Statistics</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="stat-label">Total Nodes</span>
                    <span class="stat-number">33</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max Depth</span>
                    <span class="stat-number">3</span>
                </div>
                <div class="stat-item" style="border-left: 3px solid #2d9e7e;">
                    <span class="stat-label">Supporting</span>
                    <span class="stat-number" style="color: #2d9e7e;">4</span>
                </div>
                <div class="stat-item" style="border-left: 3px solid #c74848;">
                    <span class="stat-label">Opposing</span>
                    <span class="stat-number" style="color: #c74848;">4</span>
                </div>
            </div>

            <h3 style="margin-top: 15px;">üé® Argument Types</h3>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(213, 240, 232, 0.85); border: 2px solid #2d9e7e;"></div>
                <span>Pro / Supporting</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(247, 224, 224, 0.85); border: 2px solid #c74848;"></div>
                <span>Con / Opposing</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 236, 217, 0.85); border: 2px solid #d97a30;"></div>
                <span>Objection</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(227, 238, 248, 0.85); border: 2px solid #4a7fb8;"></div>
                <span>Response</span>
            </div>
        </div>
    </div>

    <div id="sidebar">
        <button class="close-btn" onclick="closeSidebar()">√ó</button>
        <div id="sidebar-header"></div>
        <div id="sidebar-body"></div>
    </div>

    <div id="graph-container">
        <svg id="graph"></svg>
    </div>

    <script>
        // Graph data from Python
        const graphData = {
  "nodes": [
    {
      "id": "76a9e8f3-9da6-4a1e-86c6-e002b72932b1",
      "text": "Retributive justice dictates that the punishment must be strictly proportional to the gravity of the offense committed. For calculated, egregious crimes, the death penalty is the only penalty that matches the magnitude of the harm, upholding the moral principle that offenders must pay a price commensurate with the victim's loss of life.",
      "type": "pro",
      "side": "pro",
      "depth": 0,
      "parent_id": "meta-pro",
      "children_count": 1,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:01.458916"
    },
    {
      "id": "1ee6f145-728b-4a99-a585-d2516d1b7747",
      "text": "The death penalty provides the highest moral certainty of public security through absolute incapacitation. It permanently prevents convicted murderers from ever committing further violence\u2014through prison escape, parole, or acts against staff\u2014a guarantee that mere life imprisonment cannot reliably afford.",
      "type": "pro",
      "side": "pro",
      "depth": 0,
      "parent_id": "meta-pro",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:01.459449"
    },
    {
      "id": "7b3e0990-0da7-4f8d-afdf-e73ad59edc0c",
      "text": "The state's justified use of the death penalty affirms the paramount moral value of innocent human life. By designating deliberate murder as an offense warranting the ultimate forfeiture, society enacts a powerful, non-negotiable moral condemnation that reinforces respect for life across the social contract.",
      "type": "pro",
      "side": "pro",
      "depth": 0,
      "parent_id": "meta-pro",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:01.460127"
    },
    {
      "id": "6ccf82c3-6b2a-4e6f-b67c-f83674bc5e14",
      "text": "When reliable data suggests a measurable deterrent effect, the death penalty is morally justified on utilitarian grounds. The state has an unavoidable moral obligation to prioritize policies that save the lives of potential future innocent victims, even if that necessitates executing proven offenders who have already committed grave harm.",
      "type": "pro",
      "side": "pro",
      "depth": 0,
      "parent_id": "meta-pro",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:01.460613"
    },
    {
      "id": "18269b27-37fb-48a7-a859-ec7d3584f1bf",
      "text": "Executing a person shows that killing is an acceptable act when sanctioned by the state, thereby contradicting the supposed non-negotiable moral condemnation and devaluing human life generally.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "7b3e0990-0da7-4f8d-afdf-e73ad59edc0c",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:11.085199"
    },
    {
      "id": "a649721d-8aef-40cb-b302-867f4d95656c",
      "text": "There is no empirical evidence that the death penalty reinforces respect for life or acts as a deterrent; studies consistently show that murder rates are not systematically lower in retentionist states compared to abolitionist states.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "7b3e0990-0da7-4f8d-afdf-e73ad59edc0c",
      "children_count": 1,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:11.086071"
    },
    {
      "id": "b444663d-2d9a-4a3d-8073-70fe94179992",
      "text": "The principle of proportionality requires commensurability, not the literal identity of the harm (lex talionis); severe non-lethal punishments like life imprisonment without parole are widely recognized by modern retributive justice systems, including those across the European Union, as sufficiently proportional to the gravest losses of life. This directly contradicts the assumption that the death penalty is the *only* commensurate response.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "76a9e8f3-9da6-4a1e-86c6-e002b72932b1",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:12.426977"
    },
    {
      "id": "49116e08-b173-4156-a1b8-e9999d8ed42f",
      "text": "The guarantee of absolute incapacitation is negated by the system's irreversible error rate: 197 death row inmates have been exonerated in the U.S. since 1973, proving absolute certainty of guilt is unattainable.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "1ee6f145-728b-4a99-a585-d2516d1b7747",
      "children_count": 0,
      "references": [
        "https://deathpenaltyinfo.org/policy-issues/innocence/exonerations"
      ],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:15.088677"
    },
    {
      "id": "2b13f834-87d1-452b-be94-0f7037c05567",
      "text": "Life imprisonment without parole provides reliable public security because the risk of a convicted murderer escaping and harming the general public is statistically minute. This exaggerated focus on the vanishingly small probability of prison violence or escape fails to demonstrate that life sentences are categorically \"unreliable\" as safeguards against recidivism.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "1ee6f145-728b-4a99-a585-d2516d1b7747",
      "children_count": 1,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:15.089400"
    },
    {
      "id": "f41ace35-4887-4406-a1ec-ecd61294caaa",
      "text": "Empirical evidence, including the rigorous 2012 National Research Council review, shows no statistically significant difference in homicide rates between states with and without capital punishment.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "6ccf82c3-6b2a-4e6f-b67c-f83674bc5e14",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:19.671416"
    },
    {
      "id": "6591539f-e83c-463b-87aa-17e0af99cb14",
      "text": "The strictly utilitarian justification fails because the irreversible execution of factually innocent people, of whom 190 have been exonerated in the US, constitutes an irremediable injustice that grossly violates the state's fundamental duty to protect all lives.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "6ccf82c3-6b2a-4e6f-b67c-f83674bc5e14",
      "children_count": 1,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:19.672574"
    },
    {
      "id": "bd4f476e-3cb5-4970-944b-d5da960aff7a",
      "text": "The state\u2019s judicial use of lethal force is fundamentally distinct from criminal murder, just as legal systems universally distinguish necessary self-defense or wartime combat from an unjustified crime. This process difference, enforced through due process, prevents state execution from morally equating to the crime it condemns.",
      "type": "response",
      "side": "pro",
      "depth": 2,
      "parent_id": "18269b27-37fb-48a7-a859-ec7d3584f1bf",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:22.890866"
    },
    {
      "id": "7dc76954-c8f0-4f36-bc55-13da122f4cfd",
      "text": "Due process and legislative authorization fundamentally distinguish state execution from murder, preventing the normalization of violence; empirical data confirms the retention or abolition of the death penalty has no measurable correlation with overall national homicide rates.",
      "type": "response",
      "side": "pro",
      "depth": 2,
      "parent_id": "18269b27-37fb-48a7-a859-ec7d3584f1bf",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:22.892052"
    },
    {
      "id": "2b5f68cd-0b47-4554-a605-5c7423ef12df",
      "text": "The death penalty reinforces respect for life not through fear of punishment, but by demonstrating that the state holds innocent human life so highly that its willful destruction ethically demands the ultimate retributive penalty.",
      "type": "response",
      "side": "pro",
      "depth": 2,
      "parent_id": "a649721d-8aef-40cb-b302-867f4d95656c",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:26.768421"
    },
    {
      "id": "0f86c2a3-0954-4c1f-9244-3c2444a5a94d",
      "text": "Defining \"reliable public security\" solely by the low risk of escape ignores the continuous and significant security threat posed to prison staff and visitors, which is an inherent and costly failure of safety within the justice system.",
      "type": "response",
      "side": "pro",
      "depth": 2,
      "parent_id": "2b13f834-87d1-452b-be94-0f7037c05567",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:28.773314"
    },
    {
      "id": "fa698f14-2291-4f87-9453-c4a08ead3eb1",
      "text": "A strict utilitarian calculus weighs the known cost of executing the innocent against the statistical benefit of lives saved by deterrence and incapacitation. The moral justification only fails if research demonstrates that the death penalty provides negative net utility overall.",
      "type": "response",
      "side": "pro",
      "depth": 2,
      "parent_id": "6591539f-e83c-463b-87aa-17e0af99cb14",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:32.746157"
    },
    {
      "id": "9b571420-0d00-4ba2-ba83-3b2aa1e97543",
      "text": "The finality of the death penalty means an irreversible moral error occurs when an innocent person is executed. Post-conviction evidence, such as DNA testing in the United States, has led to numerous exonerations of death row inmates, demonstrating the legal system's fundamental fallibility and the impossibility of correcting this ultimate injustice.",
      "type": "con",
      "side": "con",
      "depth": 0,
      "parent_id": "meta-con",
      "children_count": 1,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:40.278048"
    },
    {
      "id": "a0c6de3f-28a1-4717-8725-8ceb0850b2b7",
      "text": "The death penalty violates the fundamental right to life, representing a cruel and inhuman punishment incompatible with modern ethical standards. Nearly all member states of the European Union have abolished capital punishment, reflecting a broad consensus among developed democracies that it is contrary to human dignity.",
      "type": "con",
      "side": "con",
      "depth": 0,
      "parent_id": "meta-con",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:40.278492"
    },
    {
      "id": "34148b82-7ca7-4e67-b9c1-505fee16c20d",
      "text": "The application of the death penalty is racially discriminatory, with defendants who murder white victims being statistically more likely to be sentenced to death than those who murder Black victims.",
      "type": "con",
      "side": "con",
      "depth": 0,
      "parent_id": "meta-con",
      "children_count": 1,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:40.278783"
    },
    {
      "id": "cb8c468d-d6d3-429a-8a4c-76d4320647d5",
      "text": "The death penalty lacks a unique deterrent effect that would morally justify its exceptional severity. Abolitionist countries like Canada and Australia often maintain homicide rates comparable to or lower than retentionist jurisdictions, challenging the idea that ultimate retribution is necessary for ultimate prevention.",
      "type": "con",
      "side": "con",
      "depth": 0,
      "parent_id": "meta-con",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:40.279021"
    },
    {
      "id": "ce854fe3-41d3-4704-b0c5-1973cef0677f",
      "text": "Developed democracies like the United States and Japan reject the notion of an absolute ban, judicially upholding the death penalty as a morally proportional and constitutionally permissible punishment for the gravest crimes, such as premeditated murder.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "a0c6de3f-28a1-4717-8725-8ceb0850b2b7",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:49.887692"
    },
    {
      "id": "9c4bdb66-7c90-4c00-aa64-2a82b22bbf35",
      "text": "No broad consensus exists among developed democracies; major nations like the United States and Japan actively utilize capital punishment within constitutional frameworks and modern ethical standards.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "a0c6de3f-28a1-4717-8725-8ceb0850b2b7",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:49.888378"
    },
    {
      "id": "a3b1db14-f602-4d75-b465-be1ab35e1b4a",
      "text": "Racial discrimination indicates a failure of legal due process, not a universal moral indictment of the death penalty; effective systems in countries like Singapore demonstrate that non-discriminatory application for specific severe crimes is functionally achievable.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "34148b82-7ca7-4e67-b9c1-505fee16c20d",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:50.393214"
    },
    {
      "id": "ba878560-bb20-4a05-a659-57a4bcb9d183",
      "text": "Comparing overall homicide rates between vastly different nations, such as Canada and retentionist US states, lacks control for massive confounding variables like socioeconomic conditions, differential policing, and gun control laws, making the correlation unreliable evidence against specific deterrence.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "cb8c468d-d6d3-429a-8a4c-76d4320647d5",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:52.037243"
    },
    {
      "id": "f19850cb-44b1-49fd-ac9b-08d0d58e95fb",
      "text": "The moral justification for the death penalty lies in the principle of retributive justice, which holds that the severest crimes mandate a proportional penalty, entirely independent of its effect on future crime prevention. Retribution serves as a standalone moral framework that views the death penalty as justly deserved punishment for the uniquely grave nature of murder.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "cb8c468d-d6d3-429a-8a4c-76d4320647d5",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:52.037828"
    },
    {
      "id": "c3beedf3-25dc-4633-a462-cd8658cfe3b2",
      "text": "Exonerations prove the legal system has successful, functioning judicial checkpoints that proactively stop the specific irreversible error of executing the innocent.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "9b571420-0d00-4ba2-ba83-3b2aa1e97543",
      "children_count": 1,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:53:54.363383"
    },
    {
      "id": "1f867026-1bf0-4ebd-9d5d-fb6c986ae353",
      "text": "Systemic legal and procedural errors inevitably lead to the irreversible execution of the innocent, proving that no judicial system, including Singapore\u2019s, can functionally eliminate non-discriminatory injustice.",
      "type": "response",
      "side": "con",
      "depth": 2,
      "parent_id": "a3b1db14-f602-4d75-b465-be1ab35e1b4a",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:54:02.840273"
    },
    {
      "id": "3cd1d799-a1aa-4580-838a-5a498ea3d3b2",
      "text": "Singapore does not prove non-discriminatory application; its system unfairly targets foreign nationals, who consistently make up the majority of those executed for drug offenses, demonstrating bias based on jurisdiction and limited access to legal counsel.",
      "type": "response",
      "side": "con",
      "depth": 2,
      "parent_id": "a3b1db14-f602-4d75-b465-be1ab35e1b4a",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:54:02.841050"
    },
    {
      "id": "2bd74c93-0d5b-4b41-a648-d33572c026f0",
      "text": "Retributive justice requires proportionality, but the death penalty is an irreversible punishment that cannot be justly proportioned against the inherent risk of executing an innocent person, violating the standard of fairness central to retribution. Life imprisonment without parole satisfies the requirement for severe and permanent punishment without introducing this error.",
      "type": "response",
      "side": "con",
      "depth": 2,
      "parent_id": "f19850cb-44b1-49fd-ac9b-08d0d58e95fb",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:54:03.504038"
    },
    {
      "id": "7925ef86-28a0-4b12-8c82-519455e0f708",
      "text": "Retributive justice is impossible when capital sentencing demonstrably depends on the defendant\u2019s race and quality of counsel rather than solely the gravity of the offense.",
      "type": "response",
      "side": "con",
      "depth": 2,
      "parent_id": "f19850cb-44b1-49fd-ac9b-08d0d58e95fb",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:54:03.505563"
    },
    {
      "id": "3c7360f2-e7a8-4826-9cd4-926d0438c1e6",
      "text": "Exoneration is the *prevention* of the ultimate injustice, not its correction; once the state executes an innocent person, the error becomes inherently and physically irreversible, regardless of subsequent evidence.",
      "type": "response",
      "side": "con",
      "depth": 2,
      "parent_id": "c3beedf3-25dc-4633-a462-cd8658cfe3b2",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:54:03.915939"
    },
    {
      "id": "c63cb9d2-4e89-440b-b1fc-00eb6f381368",
      "text": "The goal of a retributive framework is to define proportional punishment in principle; failures like race bias in US courts demonstrate a failure of flawed human implementation, not a necessary logical flaw in the theory of commensurate severity itself.",
      "type": "response",
      "side": "pro",
      "depth": 3,
      "parent_id": "7925ef86-28a0-4b12-8c82-519455e0f708",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:54:15.077727"
    },
    {
      "id": "3edff132-baf3-4ce5-9762-35403f47393e",
      "text": "Retributive frameworks successfully establish proportionality in the majority of non-capital sentencing, such as differentiating minor fines for petty theft from lengthy sentences for armed robbery, demonstrating the framework's functional validity beyond its application in extreme cases.",
      "type": "response",
      "side": "pro",
      "depth": 3,
      "parent_id": "7925ef86-28a0-4b12-8c82-519455e0f708",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-10T22:54:15.077757"
    },
    {
      "id": "meta-pro",
      "text": "Arguments For",
      "type": "meta-pro",
      "side": "pro",
      "depth": -1,
      "parent_id": null,
      "children_count": 4,
      "references": [],
      "source": "system",
      "created_at": "2025-10-10T22:53:01.458863"
    },
    {
      "id": "meta-con",
      "text": "Arguments Against",
      "type": "meta-con",
      "side": "con",
      "depth": -1,
      "parent_id": null,
      "children_count": 4,
      "references": [],
      "source": "system",
      "created_at": "2025-10-10T22:53:01.458863"
    }
  ],
  "links": [
    {
      "source": "7b3e0990-0da7-4f8d-afdf-e73ad59edc0c",
      "target": "18269b27-37fb-48a7-a859-ec7d3584f1bf",
      "type": "objection"
    },
    {
      "source": "7b3e0990-0da7-4f8d-afdf-e73ad59edc0c",
      "target": "a649721d-8aef-40cb-b302-867f4d95656c",
      "type": "objection"
    },
    {
      "source": "76a9e8f3-9da6-4a1e-86c6-e002b72932b1",
      "target": "b444663d-2d9a-4a3d-8073-70fe94179992",
      "type": "objection"
    },
    {
      "source": "1ee6f145-728b-4a99-a585-d2516d1b7747",
      "target": "49116e08-b173-4156-a1b8-e9999d8ed42f",
      "type": "objection"
    },
    {
      "source": "1ee6f145-728b-4a99-a585-d2516d1b7747",
      "target": "2b13f834-87d1-452b-be94-0f7037c05567",
      "type": "objection"
    },
    {
      "source": "6ccf82c3-6b2a-4e6f-b67c-f83674bc5e14",
      "target": "f41ace35-4887-4406-a1ec-ecd61294caaa",
      "type": "objection"
    },
    {
      "source": "6ccf82c3-6b2a-4e6f-b67c-f83674bc5e14",
      "target": "6591539f-e83c-463b-87aa-17e0af99cb14",
      "type": "objection"
    },
    {
      "source": "18269b27-37fb-48a7-a859-ec7d3584f1bf",
      "target": "bd4f476e-3cb5-4970-944b-d5da960aff7a",
      "type": "response"
    },
    {
      "source": "18269b27-37fb-48a7-a859-ec7d3584f1bf",
      "target": "7dc76954-c8f0-4f36-bc55-13da122f4cfd",
      "type": "response"
    },
    {
      "source": "a649721d-8aef-40cb-b302-867f4d95656c",
      "target": "2b5f68cd-0b47-4554-a605-5c7423ef12df",
      "type": "response"
    },
    {
      "source": "2b13f834-87d1-452b-be94-0f7037c05567",
      "target": "0f86c2a3-0954-4c1f-9244-3c2444a5a94d",
      "type": "response"
    },
    {
      "source": "6591539f-e83c-463b-87aa-17e0af99cb14",
      "target": "fa698f14-2291-4f87-9453-c4a08ead3eb1",
      "type": "response"
    },
    {
      "source": "a0c6de3f-28a1-4717-8725-8ceb0850b2b7",
      "target": "ce854fe3-41d3-4704-b0c5-1973cef0677f",
      "type": "objection"
    },
    {
      "source": "a0c6de3f-28a1-4717-8725-8ceb0850b2b7",
      "target": "9c4bdb66-7c90-4c00-aa64-2a82b22bbf35",
      "type": "objection"
    },
    {
      "source": "34148b82-7ca7-4e67-b9c1-505fee16c20d",
      "target": "a3b1db14-f602-4d75-b465-be1ab35e1b4a",
      "type": "objection"
    },
    {
      "source": "cb8c468d-d6d3-429a-8a4c-76d4320647d5",
      "target": "ba878560-bb20-4a05-a659-57a4bcb9d183",
      "type": "objection"
    },
    {
      "source": "cb8c468d-d6d3-429a-8a4c-76d4320647d5",
      "target": "f19850cb-44b1-49fd-ac9b-08d0d58e95fb",
      "type": "objection"
    },
    {
      "source": "9b571420-0d00-4ba2-ba83-3b2aa1e97543",
      "target": "c3beedf3-25dc-4633-a462-cd8658cfe3b2",
      "type": "objection"
    },
    {
      "source": "a3b1db14-f602-4d75-b465-be1ab35e1b4a",
      "target": "1f867026-1bf0-4ebd-9d5d-fb6c986ae353",
      "type": "response"
    },
    {
      "source": "a3b1db14-f602-4d75-b465-be1ab35e1b4a",
      "target": "3cd1d799-a1aa-4580-838a-5a498ea3d3b2",
      "type": "response"
    },
    {
      "source": "f19850cb-44b1-49fd-ac9b-08d0d58e95fb",
      "target": "2bd74c93-0d5b-4b41-a648-d33572c026f0",
      "type": "response"
    },
    {
      "source": "f19850cb-44b1-49fd-ac9b-08d0d58e95fb",
      "target": "7925ef86-28a0-4b12-8c82-519455e0f708",
      "type": "response"
    },
    {
      "source": "c3beedf3-25dc-4633-a462-cd8658cfe3b2",
      "target": "3c7360f2-e7a8-4826-9cd4-926d0438c1e6",
      "type": "response"
    },
    {
      "source": "7925ef86-28a0-4b12-8c82-519455e0f708",
      "target": "c63cb9d2-4e89-440b-b1fc-00eb6f381368",
      "type": "response"
    },
    {
      "source": "7925ef86-28a0-4b12-8c82-519455e0f708",
      "target": "3edff132-baf3-4ce5-9762-35403f47393e",
      "type": "response"
    },
    {
      "source": "meta-pro",
      "target": "76a9e8f3-9da6-4a1e-86c6-e002b72932b1",
      "type": "meta-link"
    },
    {
      "source": "meta-pro",
      "target": "1ee6f145-728b-4a99-a585-d2516d1b7747",
      "type": "meta-link"
    },
    {
      "source": "meta-pro",
      "target": "7b3e0990-0da7-4f8d-afdf-e73ad59edc0c",
      "type": "meta-link"
    },
    {
      "source": "meta-pro",
      "target": "6ccf82c3-6b2a-4e6f-b67c-f83674bc5e14",
      "type": "meta-link"
    },
    {
      "source": "meta-con",
      "target": "9b571420-0d00-4ba2-ba83-3b2aa1e97543",
      "type": "meta-link"
    },
    {
      "source": "meta-con",
      "target": "a0c6de3f-28a1-4717-8725-8ceb0850b2b7",
      "type": "meta-link"
    },
    {
      "source": "meta-con",
      "target": "34148b82-7ca7-4e67-b9c1-505fee16c20d",
      "type": "meta-link"
    },
    {
      "source": "meta-con",
      "target": "cb8c468d-d6d3-429a-8a4c-76d4320647d5",
      "type": "meta-link"
    }
  ]
};

        // Dimensions
        const width = window.innerWidth;
        const height = window.innerHeight - 70;

        // ========== TEXT PROCESSING UTILITIES ==========

        /**
         * Extract first complete sentence(s) up to a character limit
         */
        function extractFirstSentences(text, maxChars) {
            // Match sentences (ending with . ! ? or .)
            const sentences = text.match(/[^.!?]+[.!?]+/g) || [];

            if (sentences.length === 0) {
                return truncateAtWord(text, maxChars);
            }

            let result = '';
            for (const sentence of sentences) {
                if ((result + sentence).length <= maxChars) {
                    result += sentence;
                } else {
                    break;
                }
            }

            // If we got at least one sentence, return it
            if (result.length > 0) {
                return result.trim();
            }

            // Otherwise, truncate the first sentence at word boundary
            return truncateAtWord(sentences[0], maxChars);
        }

        /**
         * Truncate text at word boundary
         */
        function truncateAtWord(text, maxChars) {
            if (text.length <= maxChars) {
                return text;
            }

            // Find last space before maxChars
            let truncated = text.substring(0, maxChars);
            const lastSpace = truncated.lastIndexOf(' ');

            if (lastSpace > maxChars * 0.6) {
                truncated = truncated.substring(0, lastSpace);
            }

            return truncated.trim() + '...';
        }

        /**
         * Get display text for node based on depth
         */
        function getNodeDisplayText(d) {
            // Meta nodes show full text
            if (d.type === 'meta-pro' || d.type === 'meta-con') {
                return d.text;
            }

            // Character limits based on depth
            const limits = {
                0: 120,  // Root nodes - show more
                1: 90,
                2: 70,
                3: 50,
                4: 35,
                5: 30
            };

            const maxChars = limits[Math.min(d.depth, 5)];
            return extractFirstSentences(d.text, maxChars);
        }

        /**
         * Get tooltip text (2-3 sentences)
         */
        function getTooltipText(d) {
            const preview = extractFirstSentences(d.text, 300);
            return `[${d.type.toUpperCase()}] ${preview}`;
        }

        /**
         * Calculate node radius based on importance and text length
         */
        function getNodeRadius(d) {
            // Meta nodes are MUCH larger to be prominent cluster centers
            if (d.type === 'meta-pro' || d.type === 'meta-con') {
                return 120;
            }

            // Base radius by depth
            const baseRadius = {
                0: 45,  // Root nodes largest
                1: 35,
                2: 30,
                3: 25,
                4: 22,
                5: 20
            };

            const base = baseRadius[Math.min(d.depth, 5)] || 20;

            // Adjust slightly based on text length
            const textFactor = Math.sqrt(d.text.length) * 0.3;

            return base + textFactor;
        }

        /**
         * Get foreignObject dimensions for text wrapping
         */
        function getForeignObjectSize(d) {
            // Meta nodes get much larger text areas
            if (d.type === 'meta-pro' || d.type === 'meta-con') {
                return {
                    width: 320,
                    height: 120
                };
            }

            const widths = {
                0: 200,
                1: 170,
                2: 150,
                3: 120,
                4: 100,
                5: 85
            };

            const heights = {
                0: 70,
                1: 60,
                2: 55,
                3: 50,
                4: 45,
                5: 40
            };

            return {
                width: widths[Math.min(d.depth, 5)] || 85,
                height: heights[Math.min(d.depth, 5)] || 40
            };
        }

        // Create SVG
        const svg = d3.select("#graph")
            .attr("width", width)
            .attr("height", height);

        // Create zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });

        svg.call(zoom);

        // Main group for zoom/pan
        const g = svg.append("g");

        // Define unified arrow markers with clean neutral styling
        const defs = svg.append("defs");

        // Unified neutral arrow for all link types
        const arrowTypes = ['pro', 'con', 'objection', 'response', 'default', 'meta-link'];

        arrowTypes.forEach(type => {
            defs.append("marker")
                .attr("id", `arrow-${type}`)
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 10) // Position arrow tip at the edge
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-3L10,0L0,3")
                .attr("fill", "#6c757d")
                .attr("opacity", 0.5);
        });

        // Create force simulation with improved parameters to prevent overlap
        const simulation = d3.forceSimulation(graphData.nodes)
            .force("link", d3.forceLink(graphData.links).id(d => d.id).distance(d => {
                // Much longer links for better spacing
                const target = d.target;
                const depth = typeof target === 'object' ? target.depth : 0;
                const sourceRadius = getNodeRadius(d.source);
                const targetRadius = getNodeRadius(target);
                // Significantly increased spacing between nodes
                return Math.max(250, sourceRadius + targetRadius + 150 + (depth * 40));
            }).strength(0.4)) // Reduced from 0.6 to make links more flexible
            .force("charge", d3.forceManyBody()
                .strength(d => {
                    // Strong repulsion to prevent overlap
                    const radius = getNodeRadius(d);
                    return -1500 - (radius * 20); // Increased repulsion
                })
                .distanceMax(1000)) // Increased distance
            .force("center", d3.forceCenter(width / 2, height / 2).strength(0.01))
            .force("x", d3.forceX(width / 2).strength(0.005))
            // Gentler Y-force for softer layering
            .force("y", d3.forceY(d => {
                // Position nodes in horizontal layers based on depth with larger spacing
                const layerHeight = 280;
                const startY = height / 2 - 200;
                return startY + (d.depth + 1) * layerHeight;
            }).strength(0.25)) // Reduced from 0.6 for more flexibility
            .force("collision", d3.forceCollide()
                .radius(d => getNodeRadius(d) + 60) // Increased from 40
                .strength(1.0)
                .iterations(4))
            .alphaDecay(0.015)
            .velocityDecay(0.4);

        // Find meta nodes
        const metaProNode = graphData.nodes.find(n => n.type === 'meta-pro');
        const metaConNode = graphData.nodes.find(n => n.type === 'meta-con');

        // Add custom force to separate meta nodes horizontally and cluster children around them
        if (metaProNode && metaConNode) {
            simulation.force("cluster", function(alpha) {
                const separation = 1400; // Distance between meta nodes

                graphData.nodes.forEach(d => {
                    if (d.type === 'meta-pro') {
                        // Push meta-pro to the left
                        d.vx -= (d.x - (width / 2 - separation / 2)) * 0.15 * alpha;
                    } else if (d.type === 'meta-con') {
                        // Push meta-con to the right
                        d.vx += ((width / 2 + separation / 2) - d.x) * 0.15 * alpha;
                    } else {
                        // Gentle horizontal clustering only (no vertical pull)
                        let targetX;

                        if (d.side === 'pro') {
                            // Pro nodes gently attracted to left cluster
                            targetX = metaProNode.x || (width / 2 - separation / 2);
                        } else {
                            // Con nodes gently attracted to right cluster
                            targetX = metaConNode.x || (width / 2 + separation / 2);
                        }

                        // Very gentle horizontal pull only (removed vertical)
                        const dx = targetX - d.x;
                        d.vx += dx * 0.01 * alpha; // Reduced from 0.04
                    }
                });
            });
        }

        // Create links with arrows using curved paths
        const link = g.append("g")
            .selectAll("path")
            .data(graphData.links)
            .enter().append("path")
            .attr("class", d => `link ${d.type}`)
            .attr("stroke-width", d => {
                const target = d.target;
                const depth = typeof target === 'object' ? target.depth : 0;
                return Math.max(1, 4 - depth);
            })
            .attr("marker-end", d => `url(#arrow-${d.type})`)
            .attr("fill", "none");

        // Create nodes
        const node = g.append("g")
            .selectAll("g")
            .data(graphData.nodes)
            .enter().append("g")
            .attr("class", d => `node ${d.type} ${d.side} depth-${d.depth}`)
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        // Add circles to nodes (invisible, only for physics)
        node.append("circle")
            .attr("r", d => getNodeRadius(d));

        // Add multi-line labels using foreignObject for better text wrapping
        node.each(function(d) {
            const nodeGroup = d3.select(this);
            const size = getForeignObjectSize(d);
            const displayText = getNodeDisplayText(d);

            // Create foreignObject for HTML text wrapping
            const fo = nodeGroup.append("foreignObject")
                .attr("x", -size.width / 2)
                .attr("y", -size.height / 2)
                .attr("width", size.width)
                .attr("height", size.height)
                .on("click", function(event) {
                    event.stopPropagation();
                    showNodeDetails(d);
                })
                .on("dblclick", function(event) {
                    event.stopPropagation();
                    toggleSubtree(d);
                });

            // Create HTML content with just text (no badges for cleaner look)
            const div = fo.append("xhtml:div")
                .attr("class", "node-label")
                .style("width", "100%")
                .style("height", "100%")
                .style("display", "flex")
                .style("flex-direction", "column")
                .style("align-items", "center")
                .style("justify-content", "center")
                .attr("title", getTooltipText(d));

            // Add text content only (badges removed for cleaner appearance)
            div.append("xhtml:div")
                .attr("class", "node-text-content")
                .style("font-size", d.type === 'meta-pro' || d.type === 'meta-con' ? "17px" : (d.depth === 0 ? "14px" : (d.depth <= 2 ? "12px" : "11px")))
                .style("font-weight", d.type === 'meta-pro' || d.type === 'meta-con' ? "700" : (d.depth === 0 ? "600" : "500"))
                .text(displayText);
        });

        // Helper function to get text box edge point with small gap for arrow
        function getBoxEdgePoint(node, fromX, fromY) {
            const size = getForeignObjectSize(node);
            const halfW = size.width / 2;
            const halfH = size.height / 2;

            // Calculate angle from source to target
            const dx = node.x - fromX;
            const dy = node.y - fromY;
            const angle = Math.atan2(dy, dx);

            // Calculate intersection with rectangle
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);

            // Small gap for arrow (in pixels)
            const gap = 8;

            // Check which edge we hit first
            let x, y;
            if (Math.abs(cos) > Math.abs(sin) * (halfW / halfH)) {
                // Hit left or right edge
                x = node.x - Math.sign(cos) * (halfW + gap);
                y = node.y - Math.tan(angle) * Math.sign(cos) * (halfW + gap);
            } else {
                // Hit top or bottom edge
                y = node.y - Math.sign(sin) * (halfH + gap);
                x = node.x - (y - node.y) / Math.tan(angle);
            }

            return { x, y };
        }

        // Update positions on simulation tick
        simulation.on("tick", () => {
            link.each(function(d) {
                const source = d.source;
                const target = d.target;

                // Get edge points of text boxes
                const sourcePoint = getBoxEdgePoint(source, target.x, target.y);
                const targetPoint = getBoxEdgePoint(target, source.x, source.y);

                // Create straight path
                const pathData = `M ${sourcePoint.x},${sourcePoint.y} L ${targetPoint.x},${targetPoint.y}`;

                d3.select(this).attr("d", pathData);
            });

            node.attr("transform", d => `translate(${d.x},${d.y})`);
        });

        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Search functionality
        document.getElementById("search").addEventListener("input", (e) => {
            const query = e.target.value.toLowerCase();

            node.classed("highlighted", false);

            if (query) {
                node.classed("highlighted", d =>
                    d.text.toLowerCase().includes(query)
                );
            }
        });

        // ========== SIDEBAR UTILITIES ==========

        /**
         * Get path from root to node (for breadcrumb)
         */
        function getNodePath(nodeId) {
            const path = [];
            let current = graphData.nodes.find(n => n.id === nodeId);

            while (current) {
                path.unshift(current);
                if (current.parent_id) {
                    current = graphData.nodes.find(n => n.id === current.parent_id);
                } else {
                    break;
                }
            }

            return path;
        }

        /**
         * Get all children of a node
         */
        function getChildren(nodeId) {
            return graphData.nodes.filter(n => n.parent_id === nodeId);
        }

        /**
         * Count all descendants recursively
         */
        function countDescendants(nodeId) {
            const children = getChildren(nodeId);
            let count = children.length;

            children.forEach(child => {
                count += countDescendants(child.id);
            });

            return count;
        }

        /**
         * Focus camera on a specific node
         */
        function focusOnNode(nodeId) {
            const nodeData = graphData.nodes.find(n => n.id === nodeId);
            if (!nodeData) return;

            const scale = 1.5;
            const translateX = width / 2 - scale * nodeData.x;
            const translateY = height / 2 - scale * nodeData.y;

            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity.translate(translateX, translateY).scale(scale)
            );
        }

        /**
         * Copy text to clipboard
         */
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                // Show brief confirmation
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '‚úì Copied!';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2000);
            });
        }

        // Show node details in sidebar
        function showNodeDetails(d) {
            node.classed("selected", false);
            d3.select(event.target.parentNode).classed("selected", true);

            const sidebar = document.getElementById("sidebar");
            const sidebarHeader = document.getElementById("sidebar-header");
            const sidebarBody = document.getElementById("sidebar-body");

            // Build breadcrumb
            const path = getNodePath(d.id);
            let breadcrumbHtml = '<div class="breadcrumb">';
            path.forEach((node, index) => {
                if (index > 0) {
                    breadcrumbHtml += '<span class="breadcrumb-separator">‚Ä∫</span>';
                }
                const truncated = truncateAtWord(node.text, 30);
                breadcrumbHtml += `<span class="breadcrumb-item" onclick="showNodeDetails(graphData.nodes.find(n => n.id === '${node.id}'))">${truncated}</span>`;
            });
            breadcrumbHtml += '</div>';

            // Header with breadcrumb
            sidebarHeader.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                    <span class="node-badge-large ${d.type}">${d.type}</span>
                    <span class="node-badge-large ${d.side}">${d.side}</span>
                </div>
                <h2>Argument Details</h2>
                ${breadcrumbHtml}
            `;

            // Get children and descendants
            const children = getChildren(d.id);
            const descendantCount = countDescendants(d.id);

            // Build body content
            let bodyHtml = `
                <!-- Main Argument Section -->
                <div class="section">
                    <div class="section-title">üìù Argument</div>
                    <div class="node-text">${d.text}</div>
                </div>

                <!-- Action Buttons -->
                <div class="action-buttons">
                    <button class="action-btn primary" onclick="focusOnNode('${d.id}')">
                        üéØ Focus
                    </button>
                    <button class="action-btn" onclick="copyToClipboard(\`${d.text.replace(/`/g, '\\`')}\`)">
                        üìã Copy
                    </button>
                </div>

                <!-- Statistics -->
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-box-value">${d.depth}</div>
                        <div class="stat-box-label">Depth</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-box-value">${children.length}</div>
                        <div class="stat-box-label">Children</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-box-value">${descendantCount}</div>
                        <div class="stat-box-label">Descendants</div>
                    </div>
                </div>

                <!-- Metadata Grid -->
                <div class="section">
                    <div class="section-title">‚ÑπÔ∏è Metadata</div>
                    <div class="meta-grid">
                        <div class="meta-item">
                            <div class="meta-label">Source</div>
                            <div class="meta-value">${d.source}</div>
                        </div>
                        <div class="meta-item">
                            <div class="meta-label">Created</div>
                            <div class="meta-value">${new Date(d.created_at).toLocaleDateString()}</div>
                        </div>
                    </div>
                </div>
            `;

            // Add children section
            if (children.length > 0) {
                // Determine label based on node type
                let childrenLabel;
                if (d.type === 'meta-pro') {
                    childrenLabel = `${children.length} Supporting ${children.length === 1 ? 'Argument' : 'Arguments'}`;
                } else if (d.type === 'meta-con') {
                    childrenLabel = `${children.length} Opposing ${children.length === 1 ? 'Argument' : 'Arguments'}`;
                } else {
                    childrenLabel = `${children.length} ${children.length === 1 ? 'Response' : 'Responses'}`;
                }

                bodyHtml += `
                    <div class="section">
                        <div class="section-title">üå≥ ${childrenLabel}</div>
                `;

                children.forEach(child => {
                    const preview = truncateAtWord(child.text, 150);
                    bodyHtml += `
                        <div class="child-node ${child.type}" onclick="showNodeDetails(graphData.nodes.find(n => n.id === '${child.id}'))">
                            <div class="child-node-header">
                                <span class="child-node-badge ${child.type}" style="
                                    background: ${child.type === 'pro' ? '#d5f0e8' : child.type === 'con' ? '#f7e0e0' : child.type === 'objection' ? '#ffecd9' : '#e3eef8'};
                                    color: ${child.type === 'pro' ? '#2d9e7e' : child.type === 'con' ? '#c74848' : child.type === 'objection' ? '#d97a30' : '#4a7fb8'};
                                ">${child.type}</span>
                                <span style="font-size: 0.75em; color: #72777d;">${child.children_count} ${child.children_count === 1 ? 'reply' : 'replies'}</span>
                            </div>
                            <div class="child-node-text">${preview}</div>
                        </div>
                    `;
                });

                bodyHtml += '</div>';
            } else {
                bodyHtml += `
                    <div class="section">
                        <div class="empty-state">
                            <div style="font-size: 2em; margin-bottom: 10px;">üí≠</div>
                            <div>No responses yet</div>
                            <div style="font-size: 0.85em; margin-top: 5px;">This is a leaf node in the argument tree</div>
                        </div>
                    </div>
                `;
            }

            // Add references section
            if (d.references && d.references.length > 0) {
                bodyHtml += `
                    <div class="section">
                        <div class="section-title">üîó References</div>
                        <ul class="references-list">
                `;

                d.references.forEach(ref => {
                    bodyHtml += `<li><a href="${ref}" target="_blank">${ref}</a></li>`;
                });

                bodyHtml += `
                        </ul>
                    </div>
                `;
            }

            sidebarBody.innerHTML = bodyHtml;
            sidebar.classList.add("open");
        }

        function closeSidebar() {
            document.getElementById("sidebar").classList.remove("open");
            node.classed("selected", false);
        }

        // Click outside to close sidebar
        svg.on("click", () => {
            closeSidebar();
        });

        // Button handlers - Reset and fit view
        function resetAndFit() {
            // Clear search and highlights
            document.getElementById("search").value = "";
            node.classed("highlighted", false);
            closeSidebar();

            // Fit graph to view with animation
            const bounds = g.node().getBBox();
            const fullWidth = width;
            const fullHeight = height;
            const widthScale = fullWidth / bounds.width;
            const heightScale = fullHeight / bounds.height;
            const scale = Math.min(widthScale, heightScale) * 0.85;
            const translateX = fullWidth / 2 - scale * (bounds.x + bounds.width / 2);
            const translateY = fullHeight / 2 - scale * (bounds.y + bounds.height / 2);

            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity.translate(translateX, translateY).scale(scale)
            );
        }

        function toggleSubtree(d) {
            // TODO: Implement toggle subtree
            console.log("Toggle subtree not yet implemented for", d.id);
        }

        // Handle window resize
        window.addEventListener("resize", () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight - 70;
            svg.attr("width", newWidth).attr("height", newHeight);
            simulation.force("center", d3.forceCenter(newWidth / 2, newHeight / 2));
            simulation.alpha(0.3).restart();
        });
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Testing parallel processing improvements - Graph View</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Inline critical styles (graph.css will be external for customization) */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e8eef5 100%);
            overflow: hidden;
        }

        #header {
            background: white;
            border-bottom: 1px solid #a2a9b1;
            padding: 15px 20px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            height: 70px;
        }

        #header h1 {
            font-size: 1.3em;
            font-weight: 400;
            color: #202122;
            margin-bottom: 5px;
        }

        #header .meta {
            font-size: 0.85em;
            color: #72777d;
        }

        #controls {
            position: fixed;
            top: 80px;
            left: 10px;
            background: white;
            border: 1px solid #a2a9b1;
            border-radius: 4px;
            padding: 15px;
            z-index: 100;
            max-width: 250px;
        }

        #controls h3 {
            font-size: 0.9em;
            font-weight: 600;
            margin-bottom: 10px;
            color: #202122;
        }

        #controls input[type="text"] {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #a2a9b1;
            border-radius: 3px;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        #controls button {
            width: 100%;
            padding: 6px 10px;
            margin-bottom: 5px;
            border: 1px solid #a2a9b1;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.85em;
        }

        #controls button:hover {
            background: #eaecf0;
        }

        #legend {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eaecf0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 5px;
        }

        .stat-item {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #eaecf0;
            border-left-width: 3px;
            border-left-color: #0645ad;
        }

        .stat-label {
            display: block;
            font-size: 0.7em;
            color: #72777d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 3px;
        }

        .stat-number {
            display: block;
            font-size: 1.3em;
            font-weight: 600;
            color: #202122;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.85em;
        }

        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            margin-right: 10px;
            flex-shrink: 0;
        }

        #sidebar {
            position: fixed;
            top: 70px;
            right: -550px;
            width: 520px;
            height: calc(100vh - 70px);
            background: white;
            border-left: 2px solid #a2a9b1;
            transition: right 0.3s ease;
            z-index: 100;
            overflow-y: auto;
            padding: 0;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.1);
        }

        #sidebar.open {
            right: 0;
        }

        #sidebar .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #f8f9fa;
            border: 1px solid #a2a9b1;
            border-radius: 4px;
            width: 32px;
            height: 32px;
            font-size: 1.3em;
            cursor: pointer;
            color: #72777d;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 10;
        }

        #sidebar .close-btn:hover {
            background: #eaecf0;
            color: #202122;
        }

        #sidebar-header {
            background: #f8f9fa;
            border-bottom: 1px solid #eaecf0;
            padding: 20px 25px;
            padding-right: 55px;
        }

        #sidebar-header h2 {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 8px;
            color: #202122;
        }

        .breadcrumb {
            font-size: 0.8em;
            color: #72777d;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 5px;
        }

        .breadcrumb-item {
            cursor: pointer;
            transition: color 0.2s;
        }

        .breadcrumb-item:hover {
            color: #0645ad;
            text-decoration: underline;
        }

        .breadcrumb-separator {
            color: #a2a9b1;
            margin: 0 3px;
        }

        #sidebar-body {
            padding: 20px 25px;
        }

        .section {
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 0.9em;
            font-weight: 600;
            color: #72777d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .node-text {
            font-size: 0.95em;
            line-height: 1.7;
            color: #202122;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #0645ad;
        }

        .node-badge-large {
            display: inline-block;
            font-size: 0.75em;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-right: 8px;
        }

        .node-badge-large.pro {
            background: #d5f0e8;
            color: #2d9e7e;
            border: 1px solid #2d9e7e;
        }

        .node-badge-large.con {
            background: #f7e0e0;
            color: #c74848;
            border: 1px solid #c74848;
        }

        .node-badge-large.objection {
            background: #ffecd9;
            color: #d97a30;
            border: 1px solid #d97a30;
        }

        .node-badge-large.response {
            background: #e3eef8;
            color: #4a7fb8;
            border: 1px solid #4a7fb8;
        }

        .meta-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 10px;
        }

        .meta-item {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #eaecf0;
        }

        .meta-label {
            font-size: 0.75em;
            color: #72777d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .meta-value {
            font-size: 1em;
            font-weight: 600;
            color: #202122;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .action-btn {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #a2a9b1;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .action-btn:hover {
            background: #f8f9fa;
            border-color: #0645ad;
            color: #0645ad;
        }

        .action-btn.primary {
            background: #0645ad;
            color: white;
            border-color: #0645ad;
        }

        .action-btn.primary:hover {
            background: #0051a0;
        }

        .child-node {
            background: white;
            border: 1px solid #eaecf0;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 4px solid transparent;
        }

        .child-node:hover {
            border-color: #0645ad;
            border-left-color: #0645ad;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .child-node.pro {
            border-left-color: #2d9e7e;
        }

        .child-node.con {
            border-left-color: #c74848;
        }

        .child-node.objection {
            border-left-color: #d97a30;
        }

        .child-node.response {
            border-left-color: #4a7fb8;
        }

        .child-node-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .child-node-badge {
            font-size: 0.7em;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .child-node-text {
            font-size: 0.9em;
            line-height: 1.5;
            color: #202122;
        }

        .references-list {
            list-style: none;
            padding: 0;
        }

        .references-list li {
            margin-bottom: 8px;
            padding-left: 20px;
            position: relative;
        }

        .references-list li:before {
            content: "üîó";
            position: absolute;
            left: 0;
        }

        .references-list a {
            color: #0645ad;
            text-decoration: none;
            font-size: 0.85em;
            word-break: break-all;
        }

        .references-list a:hover {
            text-decoration: underline;
        }

        .empty-state {
            text-align: center;
            padding: 30px 20px;
            color: #72777d;
            font-size: 0.9em;
        }

        .stats-row {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .stat-box {
            text-align: center;
        }

        .stat-box-value {
            font-size: 1.4em;
            font-weight: 600;
            color: #0645ad;
        }

        .stat-box-label {
            font-size: 0.75em;
            color: #72777d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        #graph-container {
            position: fixed;
            top: 70px;
            left: 0;
            right: 0;
            bottom: 0;
        }

        svg {
            width: 100%;
            height: 100%;
        }

        .node {
            cursor: pointer;
        }

        .node circle {
            stroke: none;
            fill: transparent;
            opacity: 0;
            /* Keep circles for physics/collision detection but hide them */
        }

        /* Highlighted and selected states now apply to text boxes */
        .node.highlighted .node-text-content {
            outline: 3px solid #ffd700;
            outline-offset: 2px;
        }

        .node.selected .node-text-content {
            outline: 3px solid #0645ad;
            outline-offset: 2px;
        }

        /* foreignObject for text wrapping */
        .node foreignObject {
            overflow: visible;
            pointer-events: auto;  /* Make text boxes clickable */
        }

        .node-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            pointer-events: auto;  /* Make labels clickable */
        }

        .node-badge {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-bottom: 3px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.2);
        }

        .node-badge.pro {
            color: #2d9e7e;
            border-color: #2d9e7e;
        }

        .node-badge.con {
            color: #c74848;
            border-color: #c74848;
        }

        .node-badge.objection {
            color: #d97a30;
            border-color: #d97a30;
        }

        .node-badge.response {
            color: #4a7fb8;
            border-color: #4a7fb8;
        }

        .node-text-content {
            color: #202122;
            line-height: 1.4;
            word-wrap: break-word;
            background: rgba(255, 255, 255, 0.95);
            padding: 6px 10px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-left-width: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        /* Color-coded left borders by node type */
        .node.pro .node-text-content {
            border-left-color: #2d9e7e;
            background: rgba(213, 240, 232, 0.85);
        }

        .node.con .node-text-content {
            border-left-color: #c74848;
            background: rgba(247, 224, 224, 0.85);
        }

        .node.objection .node-text-content {
            border-left-color: #d97a30;
            background: rgba(255, 236, 217, 0.85);
        }

        .node.response .node-text-content {
            border-left-color: #4a7fb8;
            background: rgba(227, 238, 248, 0.85);
        }

        /* Depth-based opacity for hierarchy */
        .node.depth-0 .node-text-content {
            opacity: 1;
        }

        .node.depth-1 .node-text-content {
            opacity: 0.95;
        }

        .node.depth-2 .node-text-content {
            opacity: 0.9;
        }

        .node.depth-3 .node-text-content {
            opacity: 0.85;
        }

        .node.depth-4 .node-text-content {
            opacity: 0.8;
        }

        .node.depth-5 .node-text-content {
            opacity: 0.75;
        }

        /* Meta node text gets special styling */
        .node.meta-pro .node-text-content,
        .node.meta-con .node-text-content {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px 16px;
            font-weight: 700;
            font-size: 18px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border-left-width: 5px;
        }

        .node.meta-pro .node-text-content {
            background: rgba(213, 240, 232, 0.95);
            border-left-color: #2d9e7e;
        }

        .node.meta-con .node-text-content {
            background: rgba(247, 224, 224, 0.95);
            border-left-color: #c74848;
        }

        /* Subtle hover effects */
        .node:hover .node-text-content {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .link:hover {
            stroke-opacity: 0.8 !important;
            stroke-width: 3px;
        }

        .node title {
            font-size: 14px;
        }

        .link {
            stroke: #8b95a5;
            stroke-opacity: 0.3;
            fill: none;
            transition: all 0.2s ease;
        }

        /* Unified link styling - all types use same neutral color for cleaner look */
        .link.pro,
        .link.con,
        .link.objection,
        .link.response {
            stroke: #8b95a5;
            stroke-opacity: 0.3;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>Testing parallel processing improvements</h1>
        <div class="meta">
            6 arguments for ‚Ä¢ 6 arguments against ‚Ä¢
            36 total nodes ‚Ä¢ Max depth: 1 ‚Ä¢
            Version 2
        </div>
    </div>

    <div id="controls">
        <a href="../debates/testing-parallel-processing-improvements.html" style="display: block; width: 100%; padding: 8px 10px; margin-bottom: 10px; text-align: center; background: #0645ad; color: white; border-radius: 3px; text-decoration: none; font-size: 0.85em; font-weight: 500;">üìñ View Debate Page</a>

        <h3>üîç Search & Navigate</h3>
        <input type="text" id="search" placeholder="Search arguments...">
        <button onclick="resetAndFit()">üéØ Reset & Fit View</button>

        <div id="legend">
            <h3>üìä Tree Statistics</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="stat-label">Total Nodes</span>
                    <span class="stat-number">36</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max Depth</span>
                    <span class="stat-number">1</span>
                </div>
                <div class="stat-item" style="border-left: 3px solid #2d9e7e;">
                    <span class="stat-label">Supporting</span>
                    <span class="stat-number" style="color: #2d9e7e;">6</span>
                </div>
                <div class="stat-item" style="border-left: 3px solid #c74848;">
                    <span class="stat-label">Opposing</span>
                    <span class="stat-number" style="color: #c74848;">6</span>
                </div>
            </div>

            <h3 style="margin-top: 15px;">üé® Argument Types</h3>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(213, 240, 232, 0.85); border: 2px solid #2d9e7e;"></div>
                <span>Pro / Supporting</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(247, 224, 224, 0.85); border: 2px solid #c74848;"></div>
                <span>Con / Opposing</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 236, 217, 0.85); border: 2px solid #d97a30;"></div>
                <span>Objection</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(227, 238, 248, 0.85); border: 2px solid #4a7fb8;"></div>
                <span>Response</span>
            </div>
        </div>
    </div>

    <div id="sidebar">
        <button class="close-btn" onclick="closeSidebar()">√ó</button>
        <div id="sidebar-header"></div>
        <div id="sidebar-body"></div>
    </div>

    <div id="graph-container">
        <svg id="graph"></svg>
    </div>

    <script>
        // Graph data from Python
        const graphData = {
  "nodes": [
    {
      "id": "9c707b8a-dcbe-49ea-a875-16a560b268d3",
      "text": "Rigorous performance testing validates that hardware investments, such as modern GPU clusters or multi-socket CPUs, translate into concrete, measurable speedups. This testing ensures that costly developmental efforts yield tangible returns on investment by confirming effective efficiency gains.",
      "type": "pro",
      "side": "pro",
      "depth": 0,
      "parent_id": "meta-pro",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:38.832362+00:00"
    },
    {
      "id": "ea4592c6-a027-47bc-b855-d8a10eeaaebf",
      "text": "Profiling and benchmarking provide a crucial feedback loop necessary to identify performance bottlenecks, such as limitations imposed by Amdahl's Law. This data guides fine-grained optimization efforts by highlighting the specific sequential code sections that must be targeted for maximum parallel speedup.",
      "type": "pro",
      "side": "pro",
      "depth": 0,
      "parent_id": "meta-pro",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:38.833153+00:00"
    },
    {
      "id": "0eb7aea6-bde7-455f-8add-0b246907e6ea",
      "text": "Empirical testing is essential for generating formal scalability curves and efficiency metrics like strong versus weak scaling required for High-Performance Computing (HPC). These validated metrics are necessary for technical specifications, scientific publication, and demonstrating algorithmic efficiency across diverse processing loads.",
      "type": "pro",
      "side": "pro",
      "depth": 0,
      "parent_id": "meta-pro",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:38.833518+00:00"
    },
    {
      "id": "739ceb43-107f-475e-839a-9492a48bad23",
      "text": "Proactive stress testing identifies non-deterministic errors, such as memory access races or deadlocks, which are extremely difficult to reproduce and debug in live systems. Fixing these issues early prevents system failure, costly production downtime, and massive data corruption incidents often seen in complex distributed transactions.",
      "type": "pro",
      "side": "pro",
      "depth": 0,
      "parent_id": "meta-pro",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:38.833843+00:00"
    },
    {
      "id": "ab802dd5-70d1-4ed7-adae-1ff7e368b4b0",
      "text": "Maintaining high professional engineering standards mandates the rigorous testing and verification of complex, performance-critical parallel code changes before deployment. This ensures system stability and user trust, especially in high-stakes applications like flight control systems or high-frequency financial trading platforms.",
      "type": "pro",
      "side": "pro",
      "depth": 0,
      "parent_id": "meta-pro",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:38.834295+00:00"
    },
    {
      "id": "94e52e19-cfea-4474-9eb5-6f013e83d946",
      "text": "Historical precedence in complex, multi-threaded systems shows that seemingly subtle, undetected parallel bugs can cause catastrophic and difficult-to-reproduce failures. For example, Time-of-Check-to-Time-of-Use (TOCTTOU) vulnerabilities have frequently undermined the security and stability of operating system kernels, necessitating structured verification protocols.",
      "type": "pro",
      "side": "pro",
      "depth": 0,
      "parent_id": "meta-pro",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:38.834596+00:00"
    },
    {
      "id": "d6e481cc-f20f-4278-a140-0ec900dcdfaa",
      "text": "Rigorous performance testing confirms technical speedup but ignores the total economic viability, failing to factor in the massive upfront capital costs or the market value of the resulting output; a 50% speedup costing 300% more in capital is a net loss.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "9c707b8a-dcbe-49ea-a875-16a560b268d3",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:48.122904+00:00"
    },
    {
      "id": "174b565f-3097-40b7-aab7-dbb845b5fac4",
      "text": "The measured technical speedup often fails to translate into production efficiency due to unaccounted operational friction, such as specialized cooling and high energy draw of advanced clusters, or the extensive developer time required for software integration and maintenance.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "9c707b8a-dcbe-49ea-a875-16a560b268d3",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:48.122945+00:00"
    },
    {
      "id": "e27cfa9d-c9d0-4e67-ada0-a268d1ec5f9a",
      "text": "Stress testing only covers known risk vectors and simulated loads; it fundamentally cannot account for \"unknown unknowns,\" emergent failure modes, or compounding errors in massive, heterogeneous distributed architectures. Therefore, it only mitigates risk and reduces the likelihood of failure, rather than guaranteeing absolute prevention.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "739ceb43-107f-475e-839a-9492a48bad23",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:48.753737+00:00"
    },
    {
      "id": "171ef581-1191-44e0-b2c1-ea7e4fed2e6a",
      "text": "Massive data corruption often results from external factors, such as human operational error during deployment or unpredictable hardware and network faults like those seen in major cloud outages. Since stress tests cannot simulate all external environmental or human factors, prevention of system failure is impossible.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "739ceb43-107f-475e-839a-9492a48bad23",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:48.753764+00:00"
    },
    {
      "id": "8bec3a5c-9aef-4c7c-96d5-c0021453cf88",
      "text": "Analytical models based on complexity theory (e.g., Amdahl's Law, $O(N)$ notation) generate the theoretical scalability curves and efficiency ceilings, making empirical testing merely a validation of practical implementation.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "0eb7aea6-bde7-455f-8add-0b246907e6ea",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:49.209230+00:00"
    },
    {
      "id": "73f5e895-3b10-4780-8bf3-34e7e71effe5",
      "text": "Early-stage scientific publication and specialized technical specifications often rely on simulation results or micro-benchmarks on limited datasets for proof-of-concept, avoiding the necessity and high cost of full-scale empirical strong and weak scaling tests.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "0eb7aea6-bde7-455f-8add-0b246907e6ea",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:49.209273+00:00"
    },
    {
      "id": "a12bfc87-db4f-4275-8bd9-126db18f33e1",
      "text": "Profiling data often reveals that performance is dominated by parallelization overheads, such as costly atomic operations, excessive thread synchronization, or cache false sharing, issues entirely distinct from the sequential limits described by Amdahl\u2019s Law.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "ea4592c6-a027-47bc-b855-d8a10eeaaebf",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:50.303135+00:00"
    },
    {
      "id": "80f04a7b-c2f5-44e8-8951-07588a5cf262",
      "text": "Focusing solely on minimizing the sequential fraction ignores scalability limitations imposed by Gustafson's Law, where adding more processors yields diminishing returns due to increased communication latency and resource contention, even with a small sequential fraction.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "ea4592c6-a027-47bc-b855-d8a10eeaaebf",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:50.303161+00:00"
    },
    {
      "id": "03a5d00f-f730-4e4d-8887-3d14fdd1fbec",
      "text": "Tools like ThreadSanitizer and AddressSanitizer detect thousands of concurrency bugs in production systems like Linux and Chromium through dynamic analysis, achieving high reliability more cost-effectively than wide-scale formal verification.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "94e52e19-cfea-4474-9eb5-6f013e83d946",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:52.693272+00:00"
    },
    {
      "id": "fd8d3d80-f749-4922-8a10-008c1076f2f8",
      "text": "Full formal verification is rarely applied to large, rapidly evolving codebases due to the high time and cost; high-reliability software more often relies on memory-safe languages and rigorous development practices.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "94e52e19-cfea-4474-9eb5-6f013e83d946",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:52.693331+00:00"
    },
    {
      "id": "381780a7-41e4-48c9-b4f7-18c20eab372f",
      "text": "Exhaustive verification of non-deterministic parallel code is often computationally intractable due to state-space explosion, forcing engineers to rely on incomplete statistical testing and formal methods rather than full functional reliability testing.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "ab802dd5-70d1-4ed7-adae-1ff7e368b4b0",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:53.927456+00:00"
    },
    {
      "id": "9ef96c9a-947f-4d53-bcb7-f0b756f87541",
      "text": "The requirement for zero-latency deployment in highly competitive fields, such as modern high-frequency trading (HFT) platforms, often mandates sacrificing complete pre-deployment rigor in favor of fast iteration and robust production monitoring.",
      "type": "objection",
      "side": "con",
      "depth": 1,
      "parent_id": "ab802dd5-70d1-4ed7-adae-1ff7e368b4b0",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:53.927486+00:00"
    },
    {
      "id": "76ba2784-52e3-4a1c-8955-0641a203c2f4",
      "text": "Due to fundamental limits like Amdahl's Law, empirical analysis shows that successive parallel processing efforts yield rapidly diminishing marginal returns. Testing becomes a high-effort, low-value activity when the percentage of sequential code imposes a strict practical ceiling on achievable speedup.",
      "type": "con",
      "side": "con",
      "depth": 0,
      "parent_id": "meta-con",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:53.927556+00:00"
    },
    {
      "id": "84c467c9-617f-49e1-bd41-1c3dc0488d60",
      "text": "Prioritizing marginal parallel processing introduces unnecessary system complexity, leading to brittle code highly susceptible to difficult-to-diagnose race conditions and deadlocks. The costs associated with debugging these concurrency failures often negate the intended speed benefits.",
      "type": "con",
      "side": "con",
      "depth": 0,
      "parent_id": "meta-con",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:53.928046+00:00"
    },
    {
      "id": "be9d43ac-3988-42c9-a955-3b9bfd74c3d5",
      "text": "Extensive testing of parallel processing improvements demands disproportionately high computational resources and specialized human expertise to stress-test complex synchronization protocols. This cost presents an unfavorable opportunity trade-off compared to integrating stable, known optimizations or improving application flow externally.",
      "type": "con",
      "side": "con",
      "depth": 0,
      "parent_id": "meta-con",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:53.928333+00:00"
    },
    {
      "id": "2d13a92a-2cc4-4b3c-99f3-8683067bd555",
      "text": "Improving core parallel computation often fails to yield full throughput gains because the fundamental bottleneck inevitably shifts to limited external resources. Constraints like memory bandwidth, disk I/O, or network latency become the new performance ceiling, rendering further core parallel testing moot.",
      "type": "con",
      "side": "con",
      "depth": 0,
      "parent_id": "meta-con",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:53.928587+00:00"
    },
    {
      "id": "2a4c3b3b-ffdc-4d12-adf6-8b10ace73b7b",
      "text": "Constructing representative test suites that capture the necessary complexity of asynchronous and parallel workloads, including diverse thread scheduling and memory access patterns, is practically infeasible. This uncertainty means tested \"improvements\" may fail to materialize or introduce instability under real-world deployment conditions.",
      "type": "con",
      "side": "con",
      "depth": 0,
      "parent_id": "meta-con",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:53.928849+00:00"
    },
    {
      "id": "ff21cfbc-e834-42ff-9db8-beef121c1daf",
      "text": "Developers have a professional duty to prioritize code clarity and long-term maintainability over minor performance gains. Testing highly complex, low-level parallel optimizations violates this duty by making the code opaque and increasingly resistant to future necessary changes or bug fixes.",
      "type": "con",
      "side": "con",
      "depth": 0,
      "parent_id": "meta-con",
      "children_count": 2,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:39:53.929097+00:00"
    },
    {
      "id": "2b9f90c2-aac0-4179-bb24-52e05f36d84a",
      "text": "Cloud providers like AWS, Microsoft Azure, and large tech companies routinely validate complex asynchronous systems using proprietary production tracing and synthetic load generation, proving that sufficiently representative testing is a solved engineering problem, not an infeasible one.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "2a4c3b3b-ffdc-4d12-adf6-8b10ace73b7b",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:40:03.732904+00:00"
    },
    {
      "id": "4d1d3256-87ee-4ed5-866b-59593e16b036",
      "text": "The difficulty in modeling thread scheduling and memory patterns primarily leads to instability, while performance improvements failing to materialize is often caused by an unrepresentative *workload profile* or hardware configuration mismatch, representing two distinct testing challenges.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "2a4c3b3b-ffdc-4d12-adf6-8b10ace73b7b",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:40:03.732933+00:00"
    },
    {
      "id": "c2adfcbc-4cad-4d61-9584-db63c3fe0bbf",
      "text": "For fields like global climate modeling or fluid dynamics (CFD), massive parallelization is a necessary foundational requirement, as alternative optimizations cannot achieve the necessary computational scale for required fidelity and runtime.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "be9d43ac-3988-42c9-a955-3b9bfd74c3d5",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:40:05.671823+00:00"
    },
    {
      "id": "77779bc2-3c10-414b-bf61-36b1f8dfd014",
      "text": "Stable, known optimizations yield linear performance increases, whereas complex parallelization allows for non-linear, orders-of-magnitude speedups (10x to 100x) that are essential and unavailable through simpler methods in domains like large-scale machine learning training.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "be9d43ac-3988-42c9-a955-3b9bfd74c3d5",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:40:05.671876+00:00"
    },
    {
      "id": "77470d3a-b551-4008-bd7b-f95ce4e07e62",
      "text": "Prioritizing parallel architecture early, even for marginal current gains, is necessary preparation for utilizing future hardware with increasing core counts, avoiding higher, non-marginal architectural refactoring costs later.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "84c467c9-617f-49e1-bd41-1c3dc0488d60",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:40:07.524720+00:00"
    },
    {
      "id": "ea3f6176-644d-4f7b-be38-3a020c0bbdff",
      "text": "Modern concurrent programming models, such as Rust's strict ownership system or Erlang's actor model, provide compile-time guarantees and isolated state that significantly reduce the difficulty and cost of debugging concurrency failures.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "84c467c9-617f-49e1-bd41-1c3dc0488d60",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:40:07.524750+00:00"
    },
    {
      "id": "0703e40f-b023-4c56-a862-665277f22962",
      "text": "High-performance computing clusters show speedups often plateau due to memory hierarchy contention and cache coherence protocols, which are internal CPU architecture limits, not external bottlenecks like disk I/O.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "2d13a92a-2cc4-4b3c-99f3-8683067bd555",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:40:07.962980+00:00"
    },
    {
      "id": "8093e255-3d93-4914-8c73-701a4fcf29aa",
      "text": "Developing parallel code remains essential because increasing cores improves power efficiency for the same workload, exemplified by mobile processors using many small, low-powered cores to maximize battery life.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "2d13a92a-2cc4-4b3c-99f3-8683067bd555",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:40:07.963008+00:00"
    },
    {
      "id": "655a776d-c795-46df-bc21-c2f6f8616dc6",
      "text": "Scientific computing projects, high-frequency trading platforms, and large real-time gaming engines depend on low-level parallel optimizations that provide orders of magnitude improvement, making essential performance the primary, non-negotiable professional duty.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "ff21cfbc-e834-42ff-9db8-beef121c1daf",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:40:08.165790+00:00"
    },
    {
      "id": "d409b6cf-b199-41eb-a0b7-de548f2d02fa",
      "text": "Well-structured parallel optimization uses highly-tuned vendor libraries like NVIDIA CUDA or Intel MKL for complex work, encapsulating the complexity beneath clear, maintainable interfaces for the application code.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "ff21cfbc-e834-42ff-9db8-beef121c1daf",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:40:08.165817+00:00"
    },
    {
      "id": "12937078-7225-4c4d-a674-ea58993ffdc2",
      "text": "Parallelizing sequential code demands rigorous refactoring, which inherently enhances system robustness, identifies hidden data races, and improves concurrent consistency, making the resulting effort high value for software quality regardless of marginal speedup.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "76ba2784-52e3-4a1c-8955-0641a203c2f4",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:40:12.919023+00:00"
    },
    {
      "id": "f7c9c63b-5864-4526-b4c2-ac1d4ae385b7",
      "text": "Achieving massive system throughput, such as handling millions of concurrent transactions in cloud services, is often the goal of parallelization, providing high capacity value even when individual per-transaction latency gains (Amdahl's concern) are minimal.",
      "type": "objection",
      "side": "pro",
      "depth": 1,
      "parent_id": "76ba2784-52e3-4a1c-8955-0641a203c2f4",
      "children_count": 0,
      "references": [],
      "source": "ai-generated",
      "created_at": "2025-10-11T14:40:12.919051+00:00"
    },
    {
      "id": "meta-pro",
      "text": "Arguments For",
      "type": "meta-pro",
      "side": "pro",
      "depth": -1,
      "parent_id": null,
      "children_count": 6,
      "references": [],
      "source": "system",
      "created_at": "2025-10-11T14:39:38.832267+00:00"
    },
    {
      "id": "meta-con",
      "text": "Arguments Against",
      "type": "meta-con",
      "side": "con",
      "depth": -1,
      "parent_id": null,
      "children_count": 6,
      "references": [],
      "source": "system",
      "created_at": "2025-10-11T14:39:38.832267+00:00"
    }
  ],
  "links": [
    {
      "source": "9c707b8a-dcbe-49ea-a875-16a560b268d3",
      "target": "d6e481cc-f20f-4278-a140-0ec900dcdfaa",
      "type": "objection"
    },
    {
      "source": "9c707b8a-dcbe-49ea-a875-16a560b268d3",
      "target": "174b565f-3097-40b7-aab7-dbb845b5fac4",
      "type": "objection"
    },
    {
      "source": "739ceb43-107f-475e-839a-9492a48bad23",
      "target": "e27cfa9d-c9d0-4e67-ada0-a268d1ec5f9a",
      "type": "objection"
    },
    {
      "source": "739ceb43-107f-475e-839a-9492a48bad23",
      "target": "171ef581-1191-44e0-b2c1-ea7e4fed2e6a",
      "type": "objection"
    },
    {
      "source": "0eb7aea6-bde7-455f-8add-0b246907e6ea",
      "target": "8bec3a5c-9aef-4c7c-96d5-c0021453cf88",
      "type": "objection"
    },
    {
      "source": "0eb7aea6-bde7-455f-8add-0b246907e6ea",
      "target": "73f5e895-3b10-4780-8bf3-34e7e71effe5",
      "type": "objection"
    },
    {
      "source": "ea4592c6-a027-47bc-b855-d8a10eeaaebf",
      "target": "a12bfc87-db4f-4275-8bd9-126db18f33e1",
      "type": "objection"
    },
    {
      "source": "ea4592c6-a027-47bc-b855-d8a10eeaaebf",
      "target": "80f04a7b-c2f5-44e8-8951-07588a5cf262",
      "type": "objection"
    },
    {
      "source": "94e52e19-cfea-4474-9eb5-6f013e83d946",
      "target": "03a5d00f-f730-4e4d-8887-3d14fdd1fbec",
      "type": "objection"
    },
    {
      "source": "94e52e19-cfea-4474-9eb5-6f013e83d946",
      "target": "fd8d3d80-f749-4922-8a10-008c1076f2f8",
      "type": "objection"
    },
    {
      "source": "ab802dd5-70d1-4ed7-adae-1ff7e368b4b0",
      "target": "381780a7-41e4-48c9-b4f7-18c20eab372f",
      "type": "objection"
    },
    {
      "source": "ab802dd5-70d1-4ed7-adae-1ff7e368b4b0",
      "target": "9ef96c9a-947f-4d53-bcb7-f0b756f87541",
      "type": "objection"
    },
    {
      "source": "2a4c3b3b-ffdc-4d12-adf6-8b10ace73b7b",
      "target": "2b9f90c2-aac0-4179-bb24-52e05f36d84a",
      "type": "objection"
    },
    {
      "source": "2a4c3b3b-ffdc-4d12-adf6-8b10ace73b7b",
      "target": "4d1d3256-87ee-4ed5-866b-59593e16b036",
      "type": "objection"
    },
    {
      "source": "be9d43ac-3988-42c9-a955-3b9bfd74c3d5",
      "target": "c2adfcbc-4cad-4d61-9584-db63c3fe0bbf",
      "type": "objection"
    },
    {
      "source": "be9d43ac-3988-42c9-a955-3b9bfd74c3d5",
      "target": "77779bc2-3c10-414b-bf61-36b1f8dfd014",
      "type": "objection"
    },
    {
      "source": "84c467c9-617f-49e1-bd41-1c3dc0488d60",
      "target": "77470d3a-b551-4008-bd7b-f95ce4e07e62",
      "type": "objection"
    },
    {
      "source": "84c467c9-617f-49e1-bd41-1c3dc0488d60",
      "target": "ea3f6176-644d-4f7b-be38-3a020c0bbdff",
      "type": "objection"
    },
    {
      "source": "2d13a92a-2cc4-4b3c-99f3-8683067bd555",
      "target": "0703e40f-b023-4c56-a862-665277f22962",
      "type": "objection"
    },
    {
      "source": "2d13a92a-2cc4-4b3c-99f3-8683067bd555",
      "target": "8093e255-3d93-4914-8c73-701a4fcf29aa",
      "type": "objection"
    },
    {
      "source": "ff21cfbc-e834-42ff-9db8-beef121c1daf",
      "target": "655a776d-c795-46df-bc21-c2f6f8616dc6",
      "type": "objection"
    },
    {
      "source": "ff21cfbc-e834-42ff-9db8-beef121c1daf",
      "target": "d409b6cf-b199-41eb-a0b7-de548f2d02fa",
      "type": "objection"
    },
    {
      "source": "76ba2784-52e3-4a1c-8955-0641a203c2f4",
      "target": "12937078-7225-4c4d-a674-ea58993ffdc2",
      "type": "objection"
    },
    {
      "source": "76ba2784-52e3-4a1c-8955-0641a203c2f4",
      "target": "f7c9c63b-5864-4526-b4c2-ac1d4ae385b7",
      "type": "objection"
    },
    {
      "source": "meta-pro",
      "target": "9c707b8a-dcbe-49ea-a875-16a560b268d3",
      "type": "meta-link"
    },
    {
      "source": "meta-pro",
      "target": "ea4592c6-a027-47bc-b855-d8a10eeaaebf",
      "type": "meta-link"
    },
    {
      "source": "meta-pro",
      "target": "0eb7aea6-bde7-455f-8add-0b246907e6ea",
      "type": "meta-link"
    },
    {
      "source": "meta-pro",
      "target": "739ceb43-107f-475e-839a-9492a48bad23",
      "type": "meta-link"
    },
    {
      "source": "meta-pro",
      "target": "ab802dd5-70d1-4ed7-adae-1ff7e368b4b0",
      "type": "meta-link"
    },
    {
      "source": "meta-pro",
      "target": "94e52e19-cfea-4474-9eb5-6f013e83d946",
      "type": "meta-link"
    },
    {
      "source": "meta-con",
      "target": "76ba2784-52e3-4a1c-8955-0641a203c2f4",
      "type": "meta-link"
    },
    {
      "source": "meta-con",
      "target": "84c467c9-617f-49e1-bd41-1c3dc0488d60",
      "type": "meta-link"
    },
    {
      "source": "meta-con",
      "target": "be9d43ac-3988-42c9-a955-3b9bfd74c3d5",
      "type": "meta-link"
    },
    {
      "source": "meta-con",
      "target": "2d13a92a-2cc4-4b3c-99f3-8683067bd555",
      "type": "meta-link"
    },
    {
      "source": "meta-con",
      "target": "2a4c3b3b-ffdc-4d12-adf6-8b10ace73b7b",
      "type": "meta-link"
    },
    {
      "source": "meta-con",
      "target": "ff21cfbc-e834-42ff-9db8-beef121c1daf",
      "type": "meta-link"
    }
  ]
};

        // Dimensions
        const width = window.innerWidth;
        const height = window.innerHeight - 70;

        // ========== TEXT PROCESSING UTILITIES ==========

        /**
         * Extract first complete sentence(s) up to a character limit
         */
        function extractFirstSentences(text, maxChars) {
            // Match sentences (ending with . ! ? or .)
            const sentences = text.match(/[^.!?]+[.!?]+/g) || [];

            if (sentences.length === 0) {
                return truncateAtWord(text, maxChars);
            }

            let result = '';
            for (const sentence of sentences) {
                if ((result + sentence).length <= maxChars) {
                    result += sentence;
                } else {
                    break;
                }
            }

            // If we got at least one sentence, return it
            if (result.length > 0) {
                return result.trim();
            }

            // Otherwise, truncate the first sentence at word boundary
            return truncateAtWord(sentences[0], maxChars);
        }

        /**
         * Truncate text at word boundary
         */
        function truncateAtWord(text, maxChars) {
            if (text.length <= maxChars) {
                return text;
            }

            // Find last space before maxChars
            let truncated = text.substring(0, maxChars);
            const lastSpace = truncated.lastIndexOf(' ');

            if (lastSpace > maxChars * 0.6) {
                truncated = truncated.substring(0, lastSpace);
            }

            return truncated.trim() + '...';
        }

        /**
         * Get display text for node based on depth
         */
        function getNodeDisplayText(d) {
            // Meta nodes show full text
            if (d.type === 'meta-pro' || d.type === 'meta-con') {
                return d.text;
            }

            // Character limits based on depth
            const limits = {
                0: 120,  // Root nodes - show more
                1: 90,
                2: 70,
                3: 50,
                4: 35,
                5: 30
            };

            const maxChars = limits[Math.min(d.depth, 5)];
            return extractFirstSentences(d.text, maxChars);
        }

        /**
         * Get tooltip text (2-3 sentences)
         */
        function getTooltipText(d) {
            const preview = extractFirstSentences(d.text, 300);
            return `[${d.type.toUpperCase()}] ${preview}`;
        }

        /**
         * Calculate node radius based on importance and text length
         */
        function getNodeRadius(d) {
            // Meta nodes are MUCH larger to be prominent cluster centers
            if (d.type === 'meta-pro' || d.type === 'meta-con') {
                return 120;
            }

            // Base radius by depth
            const baseRadius = {
                0: 45,  // Root nodes largest
                1: 35,
                2: 30,
                3: 25,
                4: 22,
                5: 20
            };

            const base = baseRadius[Math.min(d.depth, 5)] || 20;

            // Adjust slightly based on text length
            const textFactor = Math.sqrt(d.text.length) * 0.3;

            return base + textFactor;
        }

        /**
         * Get foreignObject dimensions for text wrapping
         */
        function getForeignObjectSize(d) {
            // Meta nodes get much larger text areas
            if (d.type === 'meta-pro' || d.type === 'meta-con') {
                return {
                    width: 320,
                    height: 120
                };
            }

            const widths = {
                0: 200,
                1: 170,
                2: 150,
                3: 120,
                4: 100,
                5: 85
            };

            const heights = {
                0: 70,
                1: 60,
                2: 55,
                3: 50,
                4: 45,
                5: 40
            };

            return {
                width: widths[Math.min(d.depth, 5)] || 85,
                height: heights[Math.min(d.depth, 5)] || 40
            };
        }

        // Create SVG
        const svg = d3.select("#graph")
            .attr("width", width)
            .attr("height", height);

        // Create zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });

        svg.call(zoom);

        // Main group for zoom/pan
        const g = svg.append("g");

        // Define unified arrow markers with clean neutral styling
        const defs = svg.append("defs");

        // Unified neutral arrow for all link types
        const arrowTypes = ['pro', 'con', 'objection', 'response', 'default', 'meta-link'];

        arrowTypes.forEach(type => {
            defs.append("marker")
                .attr("id", `arrow-${type}`)
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 10) // Position arrow tip at the edge
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-3L10,0L0,3")
                .attr("fill", "#6c757d")
                .attr("opacity", 0.5);
        });

        // Create force simulation with improved parameters to prevent overlap
        const simulation = d3.forceSimulation(graphData.nodes)
            .force("link", d3.forceLink(graphData.links).id(d => d.id).distance(d => {
                // Much longer links for better spacing
                const target = d.target;
                const depth = typeof target === 'object' ? target.depth : 0;
                const sourceRadius = getNodeRadius(d.source);
                const targetRadius = getNodeRadius(target);
                // Significantly increased spacing between nodes
                return Math.max(250, sourceRadius + targetRadius + 150 + (depth * 40));
            }).strength(0.4)) // Reduced from 0.6 to make links more flexible
            .force("charge", d3.forceManyBody()
                .strength(d => {
                    // Strong repulsion to prevent overlap
                    const radius = getNodeRadius(d);
                    return -1500 - (radius * 20); // Increased repulsion
                })
                .distanceMax(1000)) // Increased distance
            .force("center", d3.forceCenter(width / 2, height / 2).strength(0.01))
            .force("x", d3.forceX(width / 2).strength(0.005))
            // Gentler Y-force for softer layering
            .force("y", d3.forceY(d => {
                // Position nodes in horizontal layers based on depth with larger spacing
                const layerHeight = 280;
                const startY = height / 2 - 200;
                return startY + (d.depth + 1) * layerHeight;
            }).strength(0.25)) // Reduced from 0.6 for more flexibility
            .force("collision", d3.forceCollide()
                .radius(d => getNodeRadius(d) + 60) // Increased from 40
                .strength(1.0)
                .iterations(4))
            .alphaDecay(0.015)
            .velocityDecay(0.4);

        // Find meta nodes
        const metaProNode = graphData.nodes.find(n => n.type === 'meta-pro');
        const metaConNode = graphData.nodes.find(n => n.type === 'meta-con');

        // Add custom force to separate meta nodes horizontally and cluster children around them
        if (metaProNode && metaConNode) {
            simulation.force("cluster", function(alpha) {
                const separation = 1400; // Distance between meta nodes

                graphData.nodes.forEach(d => {
                    if (d.type === 'meta-pro') {
                        // Push meta-pro to the left
                        d.vx -= (d.x - (width / 2 - separation / 2)) * 0.15 * alpha;
                    } else if (d.type === 'meta-con') {
                        // Push meta-con to the right
                        d.vx += ((width / 2 + separation / 2) - d.x) * 0.15 * alpha;
                    } else {
                        // Gentle horizontal clustering only (no vertical pull)
                        let targetX;

                        if (d.side === 'pro') {
                            // Pro nodes gently attracted to left cluster
                            targetX = metaProNode.x || (width / 2 - separation / 2);
                        } else {
                            // Con nodes gently attracted to right cluster
                            targetX = metaConNode.x || (width / 2 + separation / 2);
                        }

                        // Very gentle horizontal pull only (removed vertical)
                        const dx = targetX - d.x;
                        d.vx += dx * 0.01 * alpha; // Reduced from 0.04
                    }
                });
            });
        }

        // Create links with arrows using curved paths
        const link = g.append("g")
            .selectAll("path")
            .data(graphData.links)
            .enter().append("path")
            .attr("class", d => `link ${d.type}`)
            .attr("stroke-width", d => {
                const target = d.target;
                const depth = typeof target === 'object' ? target.depth : 0;
                return Math.max(1, 4 - depth);
            })
            .attr("marker-end", d => `url(#arrow-${d.type})`)
            .attr("fill", "none");

        // Create nodes
        const node = g.append("g")
            .selectAll("g")
            .data(graphData.nodes)
            .enter().append("g")
            .attr("class", d => `node ${d.type} ${d.side} depth-${d.depth}`)
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        // Add circles to nodes (invisible, only for physics)
        node.append("circle")
            .attr("r", d => getNodeRadius(d));

        // Add multi-line labels using foreignObject for better text wrapping
        node.each(function(d) {
            const nodeGroup = d3.select(this);
            const size = getForeignObjectSize(d);
            const displayText = getNodeDisplayText(d);

            // Create foreignObject for HTML text wrapping
            const fo = nodeGroup.append("foreignObject")
                .attr("x", -size.width / 2)
                .attr("y", -size.height / 2)
                .attr("width", size.width)
                .attr("height", size.height)
                .on("click", function(event) {
                    event.stopPropagation();
                    showNodeDetails(d);
                })
                .on("dblclick", function(event) {
                    event.stopPropagation();
                    toggleSubtree(d);
                });

            // Create HTML content with just text (no badges for cleaner look)
            const div = fo.append("xhtml:div")
                .attr("class", "node-label")
                .style("width", "100%")
                .style("height", "100%")
                .style("display", "flex")
                .style("flex-direction", "column")
                .style("align-items", "center")
                .style("justify-content", "center")
                .attr("title", getTooltipText(d));

            // Add text content only (badges removed for cleaner appearance)
            div.append("xhtml:div")
                .attr("class", "node-text-content")
                .style("font-size", d.type === 'meta-pro' || d.type === 'meta-con' ? "17px" : (d.depth === 0 ? "14px" : (d.depth <= 2 ? "12px" : "11px")))
                .style("font-weight", d.type === 'meta-pro' || d.type === 'meta-con' ? "700" : (d.depth === 0 ? "600" : "500"))
                .text(displayText);
        });

        // Helper function to get text box edge point with small gap for arrow
        function getBoxEdgePoint(node, fromX, fromY) {
            const size = getForeignObjectSize(node);
            const halfW = size.width / 2;
            const halfH = size.height / 2;

            // Calculate angle from source to target
            const dx = node.x - fromX;
            const dy = node.y - fromY;
            const angle = Math.atan2(dy, dx);

            // Calculate intersection with rectangle
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);

            // Small gap for arrow (in pixels)
            const gap = 8;

            // Check which edge we hit first
            let x, y;
            if (Math.abs(cos) > Math.abs(sin) * (halfW / halfH)) {
                // Hit left or right edge
                x = node.x - Math.sign(cos) * (halfW + gap);
                y = node.y - Math.tan(angle) * Math.sign(cos) * (halfW + gap);
            } else {
                // Hit top or bottom edge
                y = node.y - Math.sign(sin) * (halfH + gap);
                x = node.x - (y - node.y) / Math.tan(angle);
            }

            return { x, y };
        }

        // Update positions on simulation tick
        simulation.on("tick", () => {
            link.each(function(d) {
                const source = d.source;
                const target = d.target;

                // Get edge points of text boxes
                const sourcePoint = getBoxEdgePoint(source, target.x, target.y);
                const targetPoint = getBoxEdgePoint(target, source.x, source.y);

                // Create straight path
                const pathData = `M ${sourcePoint.x},${sourcePoint.y} L ${targetPoint.x},${targetPoint.y}`;

                d3.select(this).attr("d", pathData);
            });

            node.attr("transform", d => `translate(${d.x},${d.y})`);
        });

        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Search functionality
        document.getElementById("search").addEventListener("input", (e) => {
            const query = e.target.value.toLowerCase();

            node.classed("highlighted", false);

            if (query) {
                node.classed("highlighted", d =>
                    d.text.toLowerCase().includes(query)
                );
            }
        });

        // ========== SIDEBAR UTILITIES ==========

        /**
         * Get path from root to node (for breadcrumb)
         */
        function getNodePath(nodeId) {
            const path = [];
            let current = graphData.nodes.find(n => n.id === nodeId);

            while (current) {
                path.unshift(current);
                if (current.parent_id) {
                    current = graphData.nodes.find(n => n.id === current.parent_id);
                } else {
                    break;
                }
            }

            return path;
        }

        /**
         * Get all children of a node
         */
        function getChildren(nodeId) {
            return graphData.nodes.filter(n => n.parent_id === nodeId);
        }

        /**
         * Count all descendants recursively
         */
        function countDescendants(nodeId) {
            const children = getChildren(nodeId);
            let count = children.length;

            children.forEach(child => {
                count += countDescendants(child.id);
            });

            return count;
        }

        /**
         * Focus camera on a specific node
         */
        function focusOnNode(nodeId) {
            const nodeData = graphData.nodes.find(n => n.id === nodeId);
            if (!nodeData) return;

            const scale = 1.5;
            const translateX = width / 2 - scale * nodeData.x;
            const translateY = height / 2 - scale * nodeData.y;

            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity.translate(translateX, translateY).scale(scale)
            );
        }

        /**
         * Copy text to clipboard
         */
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                // Show brief confirmation
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '‚úì Copied!';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2000);
            });
        }

        // Show node details in sidebar
        function showNodeDetails(d) {
            node.classed("selected", false);
            d3.select(event.target.parentNode).classed("selected", true);

            const sidebar = document.getElementById("sidebar");
            const sidebarHeader = document.getElementById("sidebar-header");
            const sidebarBody = document.getElementById("sidebar-body");

            // Build breadcrumb
            const path = getNodePath(d.id);
            let breadcrumbHtml = '<div class="breadcrumb">';
            path.forEach((node, index) => {
                if (index > 0) {
                    breadcrumbHtml += '<span class="breadcrumb-separator">‚Ä∫</span>';
                }
                const truncated = truncateAtWord(node.text, 30);
                breadcrumbHtml += `<span class="breadcrumb-item" onclick="showNodeDetails(graphData.nodes.find(n => n.id === '${node.id}'))">${truncated}</span>`;
            });
            breadcrumbHtml += '</div>';

            // Header with breadcrumb
            sidebarHeader.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                    <span class="node-badge-large ${d.type}">${d.type}</span>
                    <span class="node-badge-large ${d.side}">${d.side}</span>
                </div>
                <h2>Argument Details</h2>
                ${breadcrumbHtml}
            `;

            // Get children and descendants
            const children = getChildren(d.id);
            const descendantCount = countDescendants(d.id);

            // Build body content
            let bodyHtml = `
                <!-- Main Argument Section -->
                <div class="section">
                    <div class="section-title">üìù Argument</div>
                    <div class="node-text">${d.text}</div>
                </div>

                <!-- Action Buttons -->
                <div class="action-buttons">
                    <button class="action-btn primary" onclick="focusOnNode('${d.id}')">
                        üéØ Focus
                    </button>
                    <button class="action-btn" onclick="copyToClipboard(\`${d.text.replace(/`/g, '\\`')}\`)">
                        üìã Copy
                    </button>
                </div>

                <!-- Statistics -->
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-box-value">${d.depth}</div>
                        <div class="stat-box-label">Depth</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-box-value">${children.length}</div>
                        <div class="stat-box-label">Children</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-box-value">${descendantCount}</div>
                        <div class="stat-box-label">Descendants</div>
                    </div>
                </div>

                <!-- Metadata Grid -->
                <div class="section">
                    <div class="section-title">‚ÑπÔ∏è Metadata</div>
                    <div class="meta-grid">
                        <div class="meta-item">
                            <div class="meta-label">Source</div>
                            <div class="meta-value">${d.source}</div>
                        </div>
                        <div class="meta-item">
                            <div class="meta-label">Created</div>
                            <div class="meta-value">${new Date(d.created_at).toLocaleDateString()}</div>
                        </div>
                    </div>
                </div>
            `;

            // Add children section
            if (children.length > 0) {
                // Determine label based on node type
                let childrenLabel;
                if (d.type === 'meta-pro') {
                    childrenLabel = `${children.length} Supporting ${children.length === 1 ? 'Argument' : 'Arguments'}`;
                } else if (d.type === 'meta-con') {
                    childrenLabel = `${children.length} Opposing ${children.length === 1 ? 'Argument' : 'Arguments'}`;
                } else {
                    childrenLabel = `${children.length} ${children.length === 1 ? 'Response' : 'Responses'}`;
                }

                bodyHtml += `
                    <div class="section">
                        <div class="section-title">üå≥ ${childrenLabel}</div>
                `;

                children.forEach(child => {
                    const preview = truncateAtWord(child.text, 150);
                    bodyHtml += `
                        <div class="child-node ${child.type}" onclick="showNodeDetails(graphData.nodes.find(n => n.id === '${child.id}'))">
                            <div class="child-node-header">
                                <span class="child-node-badge ${child.type}" style="
                                    background: ${child.type === 'pro' ? '#d5f0e8' : child.type === 'con' ? '#f7e0e0' : child.type === 'objection' ? '#ffecd9' : '#e3eef8'};
                                    color: ${child.type === 'pro' ? '#2d9e7e' : child.type === 'con' ? '#c74848' : child.type === 'objection' ? '#d97a30' : '#4a7fb8'};
                                ">${child.type}</span>
                                <span style="font-size: 0.75em; color: #72777d;">${child.children_count} ${child.children_count === 1 ? 'reply' : 'replies'}</span>
                            </div>
                            <div class="child-node-text">${preview}</div>
                        </div>
                    `;
                });

                bodyHtml += '</div>';
            } else {
                bodyHtml += `
                    <div class="section">
                        <div class="empty-state">
                            <div style="font-size: 2em; margin-bottom: 10px;">üí≠</div>
                            <div>No responses yet</div>
                            <div style="font-size: 0.85em; margin-top: 5px;">This is a leaf node in the argument tree</div>
                        </div>
                    </div>
                `;
            }

            // Add references section
            if (d.references && d.references.length > 0) {
                bodyHtml += `
                    <div class="section">
                        <div class="section-title">üîó References</div>
                        <ul class="references-list">
                `;

                d.references.forEach(ref => {
                    bodyHtml += `<li><a href="${ref}" target="_blank">${ref}</a></li>`;
                });

                bodyHtml += `
                        </ul>
                    </div>
                `;
            }

            sidebarBody.innerHTML = bodyHtml;
            sidebar.classList.add("open");
        }

        function closeSidebar() {
            document.getElementById("sidebar").classList.remove("open");
            node.classed("selected", false);
        }

        // Click outside to close sidebar
        svg.on("click", () => {
            closeSidebar();
        });

        // Button handlers - Reset and fit view
        function resetAndFit() {
            // Clear search and highlights
            document.getElementById("search").value = "";
            node.classed("highlighted", false);
            closeSidebar();

            // Fit graph to view with animation
            const bounds = g.node().getBBox();
            const fullWidth = width;
            const fullHeight = height;
            const widthScale = fullWidth / bounds.width;
            const heightScale = fullHeight / bounds.height;
            const scale = Math.min(widthScale, heightScale) * 0.85;
            const translateX = fullWidth / 2 - scale * (bounds.x + bounds.width / 2);
            const translateY = fullHeight / 2 - scale * (bounds.y + bounds.height / 2);

            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity.translate(translateX, translateY).scale(scale)
            );
        }

        function toggleSubtree(d) {
            // TODO: Implement toggle subtree
            console.log("Toggle subtree not yet implemented for", d.id);
        }

        // Handle window resize
        window.addEventListener("resize", () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight - 70;
            svg.attr("width", newWidth).attr("height", newHeight);
            simulation.force("center", d3.forceCenter(newWidth / 2, newHeight / 2));
            simulation.alpha(0.3).restart();
        });
    </script>
</body>
</html>